#!/bin/bash

# =============================================================================
# lscat - List and concatenate directory/file contents with advanced options
# Version: 1.6.0 (Added header-type "none" option)
# License: MIT - See LICENSE file for details
# Repository: https://github.com/yourusername/lscat
# =============================================================================

VERSION="1.6.0"
SCRIPT_NAME=$(basename "$0")

# Default values
DELIMITER="---"
INCLUDE_HIDDEN=false
COMPRESS=false
COMPRESS_HARD=false
SHOW_LINE_NUMBERS=false
OUTPUT_FILES=()
SKIP_PATTERNS=()
DIRECTORIES=()
FILES=()
CURRENT_DIR_ONLY=false
NON_RECURSIVE=false
POSITIONAL_DIRECTORIES=false  # Flag to track if dirs were positional
HEADER_TYPE="tree"  # tree, ls, ls-R, none

# ANSI color codes for better output (will be disabled when outputting to file)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# Flag to track if we're writing to file (so we can disable colors)
WRITING_TO_FILE=false

# =============================================================================
# Helper Functions
# =============================================================================

print_help() {
    # Plain text help (no ANSI codes)
    echo "lscat - List and Concatenate Tool"
    echo "Version: $VERSION"
    echo ""
    echo "DESCRIPTION:"
    echo "  Recursively lists directory structure and concatenates file contents with"
    echo "  customizable delimiters. Useful for AI analysis, documentation, or bulk"
    echo "  file processing."
    echo ""
    echo "USAGE:"
    echo "  $SCRIPT_NAME [OPTIONS]"
    echo ""
    echo "  Files and directories must be specified with -f or -d flags"
    echo ""
    echo "OPTIONS:"
    echo "  -d, --dir DIR1 [DIR2...]   Directories to process recursively"
    echo "                             -d * : All non-hidden directories recursively"
    echo "                             -d . : Current directory only (non-recursive)"
    echo "                             Supports patterns: *, .*, migration*/"
    echo "  -f, --file FILE1 [FILE2...] Files to process (non-recursive only)"
    echo "                             -f * : All non-hidden files in current directory"
    echo "                             -f .* : All hidden files in current directory"
    echo "                             Supports patterns: *.md, *.js, etc."
    echo "                             Can specify full paths: -f client/src/app.js"
    echo "  -s, --skip PATTERN         Skip files/dirs matching pattern (can use multiple)"
    echo "                             Patterns match at any directory level"
    echo "                             Example: -s node_modules skips ALL node_modules dirs"
    echo "  -a, --all                  Include hidden files and directories"
    echo "  -D, --destination FILE     Output file(s) (creates if doesn't exist)"
    echo "  -de, --delimiter CHAR      Delimiter between file contents (default: \"---\")"
    echo "  -c, --compress             Compress content (remove indentation and blank lines)"
    echo "  -C, --compress-hard        Aggressive compression (remove all formatting, one-line per file)"
    echo "  -l, --line-numbers         Show line numbers in file contents"
    echo "  -H, --header-type TYPE     Change header display style: tree (default), ls, ls-R, none"
    echo "                             tree: Full tree structure with branches"
    echo "                             ls: Simple ls-style list (compact)"
    echo "                             ls-R: Recursive ls-style list with subdir levels"
    echo "                             none: No headers (for space saving)"
    echo "  -i, --install              Install lscat system-wide (standalone option)"
    echo "  -h, --help                 Show this help message"
    echo "  -v, --version              Show version information"
    echo ""
    echo "BEHAVIOR:"
    echo "  lscat                      # Non-recursive tree of current dir (shows hidden)"
    echo "  lscat -d .                 # Same as above (explicit)"
    echo "  lscat -d *                 # All directories recursively"
    echo "  lscat -f *                 # All files in current directory (non-recursive)"
    echo ""
    echo "PATTERN EXAMPLES:"
    echo "  lscat -d \"*\"              # All non-hidden directories recursively"
    echo "  lscat -d \"*\" -a           # All directories (including hidden) recursively"
    echo "  lscat -d . -a              # Current directory only (including hidden)"
    echo "  lscat -f '*.md'            # All .md files in current directory"
    echo "  lscat -f \".*\"             # All hidden files in current directory"
    echo "  lscat -f 'client/src/*.js' # All .js files in client/src"
    echo "  lscat -d 'server/database/migration*/'  # All migration directories"
    echo "  lscat -s '*.log'           # Skip all .log files"
    echo "  lscat -s .git -s node_modules   # Skip .git and node_modules directories"
    echo "  lscat -s ./client/node_modules/ # Skip specific directory path"
    echo ""
    echo "HEADER TYPE EXAMPLES:"
    echo "  lscat -d . -H tree         # Default tree structure (verbose)"
    echo "  lscat -d . -H ls           # Compact ls-style listing"
    echo "  lscat -d . -H ls-R         # Recursive ls-style listing"
    echo "  lscat -d * -c -H ls        # Compact headers with compressed content"
    echo "  lscat -d * -C -H ls        # Hard compression with compact headers"
    echo "  lscat -d * -C -H none      # No headers with hard compression (max space saving)"
    echo ""
    echo "EXAMPLES:"
    echo "  $SCRIPT_NAME                           # Non-recursive list of current directory"
    echo "  $SCRIPT_NAME -d \"*\" -a -s .*         # All non-hidden recursively (skip hidden)"
    echo "  $SCRIPT_NAME -D output.txt -de \"***\"   # Use custom delimiter, output to file"
    echo "  $SCRIPT_NAME -a -c -l                  # Include hidden files, compress, line numbers"
    echo "  $SCRIPT_NAME -f *.md -d client server  # Process .md files and client/server directories"
    echo "  $SCRIPT_NAME -f .gitignore readme.md -d src  # Mix specific files and directories"
    echo ""
    echo "NOTES:"
    echo "  - Use quotes around patterns to prevent shell expansion"
    echo "  - Skip patterns prevent BOTH tree display AND file processing"
    echo "  - Skip patterns match at any depth (e.g., -s node_modules skips all node_modules)"
    echo "  - -d flag is for directories only (recursive with *)"
    echo "  - -f flag is for files only (non-recursive, current directory only)"
    echo "  - -H flag reduces header size when combining -d with -C or -c"
    echo "  - Default (no flags): non-recursive tree of current dir, shows hidden"
}

print_version() {
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "${BOLD}lscat${NC} version ${GREEN}$VERSION${NC}"
        echo "Created for efficient file concatenation and AI processing"
    else
        echo "lscat version $VERSION"
        echo "Created for efficient file concatenation and AI processing"
    fi
}

print_error() {
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "${RED}Error:${NC} $1" >&2
    else
        echo "Error: $1" >&2
    fi
}

print_warning() {
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "${YELLOW}Warning:${NC} $1" >&2
    else
        echo "Warning: $1" >&2
    fi
}

print_info() {
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "${CYAN}Info:${NC} $1"
    else
        echo "Info: $1"
    fi
}

# Installation function
install_lscat() {
    echo "Installing lscat..."
    echo "====================="
    
    # Get the script's own location
    if [[ -f "$0" ]]; then
        SCRIPT_PATH="$0"
    else
        # Fallback to the current script
        SCRIPT_PATH="./$(basename "$0")"
    fi
    
    if [[ ! -f "$SCRIPT_PATH" ]]; then
        print_error "Cannot find lscat script to install"
        exit 1
    fi
    
    # Make sure the script is executable
    chmod +x "$SCRIPT_PATH" 2>/dev/null || true
    
    echo ""
    echo "Select installation method:"
    echo "1) Current user only (~/.local/bin) - Recommended"
    echo "2) System-wide (/usr/local/bin) - Requires sudo"
    echo "3) System-wide (/usr/bin) - Requires sudo"
    echo "4) Custom location with symlink"
    echo "5) Cancel installation"
    echo ""
    
    read -p "Enter choice [1-5]: " choice
    
    case $choice in
        1)
            # User installation
            mkdir -p ~/.local/bin
            if cp "$SCRIPT_PATH" ~/.local/bin/lscat; then
                chmod +x ~/.local/bin/lscat
                echo "Installed to ~/.local/bin/lscat"
                
                # Check if PATH needs update
                if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then
                    echo "Adding ~/.local/bin to PATH..."
                    echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc
                    echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc 2>/dev/null || true
                    source ~/.bashrc 2>/dev/null || true
                fi
            else
                print_error "Failed to copy to ~/.local/bin/"
                exit 1
            fi
            ;;
        2)
            # System installation to /usr/local/bin
            if sudo cp "$SCRIPT_PATH" /usr/local/bin/lscat; then
                sudo chmod +x /usr/local/bin/lscat
                echo "Installed to /usr/local/bin/lscat"
            else
                print_error "Failed to install to /usr/local/bin"
                exit 1
            fi
            ;;
        3)
            # System installation to /usr/bin
            if sudo cp "$SCRIPT_PATH" /usr/bin/lscat; then
                sudo chmod +x /usr/bin/lscat
                echo "Installed to /usr/bin/lscat"
            else
                print_error "Failed to install to /usr/bin"
                exit 1
            fi
            ;;
        4)
            # Custom symlink method
            read -p "Enter installation directory (e.g., /opt/lscat): " install_dir
            if [[ -z "$install_dir" ]]; then
                print_error "No directory specified"
                exit 1
            fi
            
            mkdir -p "$install_dir" 2>/dev/null || sudo mkdir -p "$install_dir"
            
            if cp "$SCRIPT_PATH" "$install_dir/lscat"; then
                chmod +x "$install_dir/lscat"
                
                read -p "Create symlink in which directory? (e.g., /usr/local/bin): " symlink_dir
                if [[ -n "$symlink_dir" ]]; then
                    sudo ln -sf "$install_dir/lscat" "$symlink_dir/lscat" 2>/dev/null || ln -sf "$install_dir/lscat" "$symlink_dir/lscat"
                    echo "Installed to $install_dir/lscat with symlink in $symlink_dir"
                else
                    echo "Installed to $install_dir/lscat (no symlink created)"
                fi
            else
                print_error "Failed to install to $install_dir"
                exit 1
            fi
            ;;
        5)
            echo "Installation cancelled."
            exit 0
            ;;
        *)
            print_error "Invalid choice!"
            exit 1
            ;;
    esac
    
    # Verify installation
    echo ""
    echo "Verifying installation..."
    if command -v lscat &> /dev/null; then
        echo -e "\033[32m‚úì lscat installed successfully!\033[0m"
        echo "Run 'lscat --help' to see usage"
    else
        echo -e "\033[31m‚úó Installation completed but lscat not found in PATH\033[0m"
        echo "You may need to log out and back in, or run: source ~/.bashrc"
    fi
    
    exit 0
}

# Enhanced pattern expansion function (DIRECTORIES ONLY - recursive)
expand_patterns() {
    local items=("$@")
    local expanded_items=()
    
    for item in "${items[@]}"; do
        # Special cases
        if [[ "$item" == "*" ]]; then
            # * means all non-hidden directories recursively
            if [[ "$INCLUDE_HIDDEN" == true ]]; then
                # Include hidden directories
                while IFS= read -r -d $'\0' found_item; do
                    if [[ -d "$found_item" ]]; then
                        expanded_items+=("$found_item")
                    fi
                done < <(find . -mindepth 1 -type d -print0 2>/dev/null)
            else
                # Exclude hidden directories
                while IFS= read -r -d $'\0' found_item; do
                    if [[ -d "$found_item" ]] && [[ ! "$found_item" =~ /\. ]]; then
                        expanded_items+=("$found_item")
                    fi
                done < <(find . -mindepth 1 -type d -not -name '.*' -print0 2>/dev/null)
            fi
        elif [[ "$item" == "." ]] && [[ "$POSITIONAL_DIRECTORIES" == false ]]; then
            # . with -d flag means current directory only (non-recursive)
            expanded_items+=(".")
        elif [[ "$item" == ".*" ]]; then
            # .* means hidden directories recursively
            while IFS= read -r -d $'\0' found_item; do
                if [[ -d "$found_item" ]]; then
                    expanded_items+=("$found_item")
                fi
            done < <(find . -mindepth 1 -type d -name '.*' -print0 2>/dev/null)
        elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then
            # Contains wildcard pattern - directories only
            # First, check if it's a literal directory that exists
            if [[ -d "$item" ]]; then
                # It exists as a literal directory
                expanded_items+=("$item")
            else
                # Try to expand with shell globbing (with nullglob to avoid literal pattern)
                shopt -s nullglob
                local found_items=()
                
                # Try with current directory if no directory specified
                if [[ "$item" != */* ]] && [[ "$item" != ./* ]]; then
                    # Pattern without path - try in current directory
                    for found_item in ./$item; do
                        if [[ -d "$found_item" ]]; then
                            found_items+=("$found_item")
                        fi
                    done
                fi
                
                # Try the pattern as-is
                for found_item in $item; do
                    if [[ -d "$found_item" ]]; then
                        found_items+=("$found_item")
                    fi
                done
                shopt -u nullglob
                
                if [[ ${#found_items[@]} -eq 0 ]]; then
                    # If no matches with shell globbing, try find for more complex patterns
                    local pattern_name=$(basename "$item")
                    local pattern_dir=$(dirname "$item")
                    [[ "$pattern_dir" == "." ]] && pattern_dir="."
                    
                    # Handle directory patterns like migration*/
                    if [[ "$item" == */ ]]; then
                        # Directory pattern
                        while IFS= read -r -d $'\0' found_item; do
                            if [[ -d "$found_item" ]]; then
                                found_items+=("$found_item")
                            fi
                        done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null)
                    else
                        # General pattern (directories only)
                        while IFS= read -r -d $'\0' found_item; do
                            if [[ -d "$found_item" ]]; then
                                found_items+=("$found_item")
                            fi
                        done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null)
                    fi
                fi
                
                # Add found items
                for found_item in "${found_items[@]}"; do
                    expanded_items+=("$found_item")
                done
            fi
        else
            # No pattern, check if it's a directory
            if [[ -d "$item" ]]; then
                expanded_items+=("$item")
            elif [[ -e "$item" ]]; then
                print_warning "Skipping non-directory item in -d flag: $item"
            else
                print_error "Directory not found: $item"
                return 1
            fi
        fi
    done
    
    # Remove duplicates and empty entries
    local unique_items=()
    for item in "${expanded_items[@]}"; do
        if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then
            unique_items+=("$item")
        fi
    done
    
    # Output each item on a new line
    for item in "${unique_items[@]}"; do
        echo "$item"
    done
}

# Enhanced file pattern expansion function (FILES ONLY - non-recursive)
expand_file_patterns() {
    local items=("$@")
    local expanded_items=()
    
    for item in "${items[@]}"; do
        # Special cases
        if [[ "$item" == "*" ]]; then
            # * means all non-hidden files in current directory (non-recursive)
            if [[ "$INCLUDE_HIDDEN" == true ]]; then
                # Include hidden files
                while IFS= read -r -d $'\0' found_item; do
                    if [[ -f "$found_item" ]]; then
                        expanded_items+=("$found_item")
                    fi
                done < <(find . -maxdepth 1 -mindepth 1 -type f -print0 2>/dev/null)
            else
                # Exclude hidden files
                while IFS= read -r -d $'\0' found_item; do
                    if [[ -f "$found_item" ]]; then
                        expanded_items+=("$found_item")
                    fi
                done < <(find . -maxdepth 1 -mindepth 1 -type f -not -name '.*' -print0 2>/dev/null)
            fi
        elif [[ "$item" == ".*" ]]; then
            # .* means hidden files in current directory
            while IFS= read -r -d $'\0' found_item; do
                if [[ -f "$found_item" ]]; then
                    expanded_items+=("$found_item")
                fi
            done < <(find . -maxdepth 1 -mindepth 1 -type f -name '.*' -print0 2>/dev/null)
        elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then
            # Contains wildcard pattern - files only, non-recursive
            local pattern_name=$(basename "$item")
            local pattern_dir=$(dirname "$item")
            [[ "$pattern_dir" == "." ]] && pattern_dir="."
            
            if [[ -d "$pattern_dir" ]] || [[ "$pattern_dir" == "" ]]; then
                # Use find with maxdepth 1 for non-recursive search
                if [[ "$INCLUDE_HIDDEN" == true ]]; then
                    while IFS= read -r -d $'\0' found_item; do
                        if [[ -f "$found_item" ]]; then
                            expanded_items+=("$found_item")
                        fi
                    done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -print0 2>/dev/null)
                else
                    while IFS= read -r -d $'\0' found_item; do
                        if [[ -f "$found_item" ]] && [[ ! "$(basename "$found_item")" == .* ]]; then
                            expanded_items+=("$found_item")
                        fi
                    done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -not -name '.*' -print0 2>/dev/null)
                fi
            fi
        else
            # No pattern, check if it's a file
            if [[ -f "$item" ]]; then
                expanded_items+=("$item")
            elif [[ -e "$item" ]]; then
                print_warning "Skipping non-file item in -f flag: $item"
            else
                print_warning "File not found: $item"
            fi
        fi
    done
    
    # Remove duplicates and empty entries
    local unique_items=()
    for item in "${expanded_items[@]}"; do
        if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then
            unique_items+=("$item")
        fi
    done
    
    # Output each item on a new line
    for item in "${unique_items[@]}"; do
        echo "$item"
    done
}

# Enhanced should_skip with better directory handling
should_skip() {
    local item="$1"
    local item_name=$(basename "$item")
    
    for pattern in "${SKIP_PATTERNS[@]}"; do
        # Remove trailing / if present
        pattern="${pattern%/}"
        
        # Skip empty patterns
        [[ -z "$pattern" ]] && continue
        
        # 1. Check exact match
        if [[ "$item" == "$pattern" ]] || [[ "$item_name" == "$pattern" ]]; then
            return 0
        fi
        
        # 2. Check if pattern contains wildcards
        if [[ "$pattern" == *"*"* ]] || [[ "$pattern" == *"?"* ]] || [[ "$pattern" == *"["* ]]; then
            # Use case pattern matching
            case "$item" in
                $pattern)
                    return 0
                    ;;
            esac
            case "$item_name" in
                $pattern)
                    return 0
                    ;;
            esac
        fi
        
        # 3. Check for directory path matching (e.g., ./client/node_modules)
        # Remove leading ./ if present for better matching
        local clean_pattern="${pattern#./}"
        local clean_item="${item#./}"
        
        if [[ "$clean_item" == "$clean_pattern"* ]]; then
            # If pattern ends with a directory name and item is under that directory
            return 0
        fi
        
        # 4. Check if item is inside a skipped directory
        # For each segment of the item path, check if it matches a skip pattern
        local temp_path="$clean_item"
        while [[ "$temp_path" != "." ]] && [[ "$temp_path" != "" ]]; do
            local current_dir="$(basename "$temp_path")"
            if [[ "$current_dir" == "$clean_pattern" ]] || 
               [[ "$current_dir" == "$pattern" ]] || 
               ([[ "$pattern" == *"*"* ]] && case "$current_dir" in $pattern) true;; *) false;; esac); then
                return 0
            fi
            temp_path="$(dirname "$temp_path")"
            if [[ "$temp_path" == "/" ]] || [[ "$temp_path" == "." ]]; then
                break
            fi
        done
    done
    
    return 1
}

# Normal compression - remove indentation and blank lines
compress_content() {
    local content="$1"
    
    if [[ "$COMPRESS" == false ]] && [[ "$COMPRESS_HARD" == false ]]; then
        echo "$content"
        return
    fi
    
    # If hard compression is enabled, use that instead
    if [[ "$COMPRESS_HARD" == true ]]; then
        compress_hard_content "$content"
        return
    fi
    
    # Original compression: remove leading/trailing whitespace and empty lines
    echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d'
}

# Hard compression - remove ALL formatting, make each file one continuous line
compress_hard_content() {
    local content="$1"
    
    # First, remove all trailing/leading whitespace from each line
    content=$(echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    
    # Remove completely empty lines
    content=$(echo "$content" | sed -e '/^$/d')
    
    # Join lines with a single space, but be careful with certain patterns
    local result=""
    local in_multiline_comment=false
    local in_string=false
    local string_char=""
    
    # FIX: Define regex variables to avoid syntax errors with < > characters in conditionals
    local regex_open='[\({\[<]'
    local regex_close='[.,;:!?\)}\]>]'
    
    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" ]] && continue
        
        # Handle multiline comments
        if [[ "$in_multiline_comment" == true ]]; then
            if [[ "$line" == *"*/"* ]]; then
                in_multiline_comment=false
            fi
            result="${result}${line} "
            continue
        fi
        
        # Check if line starts a multiline comment
        if [[ "$line" == "/*"* ]] && [[ "$line" != *"*/"* ]]; then
            in_multiline_comment=true
            result="${result}${line} "
            continue
        fi
        
        if [[ -n "$result" ]]; then
            local last_char="${result: -1}"
            local first_char="${line:0:1}"
            
            # Use defined variables for pattern matching
            if [[ "$last_char" =~ $regex_open ]] || [[ "$first_char" =~ $regex_close ]]; then
                result="${result}${line} "
            else
                result="${result} ${line} "
            fi
        else
            result="${line} "
        fi
    done <<< "$content"
    
    # Clean up: remove trailing space and collapse multiple spaces
    result=$(echo "$result" | sed -e 's/[[:space:]]*$//' -e 's/[[:space:]]\+/ /g')
    
    if [[ ${#result} -gt 1000 ]] && [[ "$WRITING_TO_FILE" == false ]]; then
        print_warning "Hard compression created very long line (${#result} chars)"
    fi
    
    echo "$result"
}

# Enhanced get_tree_structure with proper skip handling
get_tree_structure() {
    local dir="$1"
    local depth="${2:-0}"
    local prefix="${3:-}"
    local recursive="${4:-true}"
    local parent_is_hidden="${5:-false}"
    local force_show_hidden="${6:-false}"
    
    # Apply non-recursive flag
    if [[ "$NON_RECURSIVE" == true ]]; then
        recursive=false
    fi
    
    # Skip entire directory if it matches skip patterns
    if should_skip "$dir"; then
        if [[ $depth -eq 0 ]]; then
            if [[ "$WRITING_TO_FILE" == false ]]; then
                echo -e "${YELLOW}üìÅ $dir (skipped)${NC}"
            else
                echo "üìÅ $dir (skipped)"
            fi
        else
            echo "${prefix}üìÅ $(basename "$dir")/ (skipped)"
        fi
        return
    fi
    
    # Check if current directory is hidden (starts with .)
    local dir_name=$(basename "$dir")
    local is_current_hidden=false
    [[ "$dir_name" == .* ]] && is_current_hidden=true
    
    # Determine if we should show this directory
    if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then
        return
    fi
    
    # Print current directory
    if [[ $depth -eq 0 ]]; then
        if [[ "$WRITING_TO_FILE" == false ]]; then
            echo -e "${BOLD}${BLUE}üìÅ $dir${NC}"
        else
            echo "üìÅ $dir"
        fi
    else
        echo "${prefix}üìÅ $dir_name/"
    fi
    
    # Find items in directory
    local find_opts=""
    if [[ "$recursive" == false ]]; then
        find_opts="-maxdepth 1"
    fi
    
    local find_cmd="find \"$dir\" $find_opts -mindepth 1"
    
    if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then
        if [[ "$is_current_hidden" == true ]]; then
            find_cmd="$find_cmd -not -name '.*'"
        else
            find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\""
        fi
    fi
    
    find_cmd="$find_cmd | sort"
    local count=0
    local total_items=0
    
    # First, count total items
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        total_items=$((total_items + 1))
    done < <(eval "$find_cmd 2>/dev/null")
    
    # Process items
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        
        local item_name=$(basename "$item")
        local is_item_hidden=false
        [[ "$item_name" == .* ]] && is_item_hidden=true
        
        # Skip if pattern matches
        if should_skip "$item"; then
            continue
        fi
        
        # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden
        if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then
            continue
        fi
        
        count=$((count + 1))
        
        # Determine if last item for pretty tree
        local next_prefix="$prefix"
        if [[ $count -eq $total_items ]]; then
            next_prefix="${prefix}    "
            echo -n "${prefix}‚îî‚îÄ‚îÄ "
        else
            next_prefix="${prefix}‚îÇ   "
            echo -n "${prefix}‚îú‚îÄ‚îÄ "
        fi
        
        if [[ -d "$item" ]]; then
            if [[ "$WRITING_TO_FILE" == false ]]; then
                echo -e "${BLUE}$item_name/${NC}"
            else
                echo "$item_name/"
            fi
            # Only recurse if recursive flag is true and not skipping
            if [[ "$recursive" == true ]] && ! should_skip "$item"; then
                get_tree_structure "$item" $((depth + 1)) "$next_prefix" "$recursive" "$is_current_hidden" "$force_show_hidden"
            fi
        else
            # Color code by file extension
            local ext="${item_name##*.}"
            if [[ "$WRITING_TO_FILE" == false ]]; then
                if [[ "$ext" == "$item_name" ]]; then
                    echo -e "${GREEN}$item_name${NC}"
                elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then
                    echo -e "${MAGENTA}$item_name${NC}"
                elif [[ "$ext" == "py" ]]; then
                    echo -e "${YELLOW}$item_name${NC}"
                elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then
                    echo -e "${CYAN}$item_name${NC}"
                elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then
                    echo -e "${GREEN}$item_name${NC}"
                else
                    echo "$item_name"
                fi
            else
                echo "$item_name"
            fi
        fi
    done < <(eval "$find_cmd 2>/dev/null")
    
    if [[ $count -eq 0 ]]; then
        echo "${prefix}    (empty)"
    fi
}

# NEW: Get ls-style structure (compact, no tree branches)
get_ls_structure() {
    local dir="$1"
    local depth="${2:-0}"
    local recursive="${3:-true}"
    local parent_is_hidden="${4:-false}"
    local force_show_hidden="${5:-false}"
    
    # Apply non-recursive flag
    if [[ "$NON_RECURSIVE" == true ]]; then
        recursive=false
    fi
    
    # Skip entire directory if it matches skip patterns
    if should_skip "$dir"; then
        if [[ $depth -eq 0 ]]; then
            if [[ "$WRITING_TO_FILE" == false ]]; then
                echo -e "${YELLOW}üìÅ $dir (skipped)${NC}"
            else
                echo "üìÅ $dir (skipped)"
            fi
        fi
        return
    fi
    
    # Check if current directory is hidden (starts with .)
    local dir_name=$(basename "$dir")
    local is_current_hidden=false
    [[ "$dir_name" == .* ]] && is_current_hidden=true
    
    # Determine if we should show this directory
    if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then
        return
    fi
    
    # Print current directory (with indentation for subdirectories in ls-R mode)
    local indent=""
    if [[ $depth -gt 0 ]] && [[ "$HEADER_TYPE" == "ls-R" ]]; then
        for ((i=0; i<depth; i++)); do
            indent="${indent}  "
        done
        echo "${indent}$dir/"
    elif [[ $depth -eq 0 ]]; then
        if [[ "$WRITING_TO_FILE" == false ]]; then
            echo -e "${BOLD}${BLUE}üìÅ $dir${NC}"
        else
            echo "üìÅ $dir"
        fi
    fi
    
    # Find items in directory
    local find_opts="-maxdepth 1"
    if [[ "$recursive" == false ]]; then
        find_opts="-maxdepth 1"
    fi
    
    local find_cmd="find \"$dir\" $find_opts -mindepth 1"
    
    if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then
        if [[ "$is_current_hidden" == true ]]; then
            find_cmd="$find_cmd -not -name '.*'"
        else
            find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\""
        fi
    fi
    
    find_cmd="$find_cmd | sort"
    
    # Process files and directories separately for better organization
    local files=()
    local subdirs=()
    
    while IFS= read -r item; do
        [[ -z "$item" ]] && continue
        
        local item_name=$(basename "$item")
        local is_item_hidden=false
        [[ "$item_name" == .* ]] && is_item_hidden=true
        
        # Skip if pattern matches
        if should_skip "$item"; then
            continue
        fi
        
        # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden
        if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then
            continue
        fi
        
        if [[ -d "$item" ]]; then
            subdirs+=("$item")
        else
            files+=("$item")
        fi
    done < <(eval "$find_cmd 2>/dev/null")
    
    # Print files first
    for item in "${files[@]}"; do
        local item_name=$(basename "$item")
        local ext="${item_name##*.}"
        
        # Add indentation for subdirectories in ls-R mode
        local item_indent="$indent"
        if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then
            item_indent="${item_indent}  "
        fi
        
        if [[ "$WRITING_TO_FILE" == false ]]; then
            if [[ "$ext" == "$item_name" ]]; then
                echo -e "${item_indent}${GREEN}$item_name${NC}"
            elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then
                echo -e "${item_indent}${MAGENTA}$item_name${NC}"
            elif [[ "$ext" == "py" ]]; then
                echo -e "${item_indent}${YELLOW}$item_name${NC}"
            elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then
                echo -e "${item_indent}${CYAN}$item_name${NC}"
            elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then
                echo -e "${item_indent}${GREEN}$item_name${NC}"
            else
                echo "${item_indent}$item_name"
            fi
        else
            echo "${item_indent}$item_name"
        fi
    done
    
    # Print directories
    for item in "${subdirs[@]}"; do
        local item_name=$(basename "$item")
        local item_indent="$indent"
        
        if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then
            item_indent="${item_indent}  "
        fi
        
        if [[ "$WRITING_TO_FILE" == false ]]; then
            echo -e "${item_indent}${BLUE}$item_name/${NC}"
        else
            echo "${item_indent}$item_name/"
        fi
        
        # Recurse into subdirectories if recursive flag is true and not skipping
        if [[ "$recursive" == true ]] && [[ "$HEADER_TYPE" == "ls-R" ]] && ! should_skip "$item"; then
            get_ls_structure "$item" $((depth + 1)) "$recursive" "$is_current_hidden" "$force_show_hidden"
        fi
    done
    
    # Print empty message if no items
    if [[ ${#files[@]} -eq 0 ]] && [[ ${#subdirs[@]} -eq 0 ]]; then
        if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then
            echo "${indent}  (empty)"
        else
            echo "    (empty)"
        fi
    fi
    
    # Add a blank line between directories in ls-R mode for readability
    if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -eq 0 ]] && [[ ${#subdirs[@]} -gt 0 ]]; then
        echo ""
    fi
}

# Process file content with options
process_file_content() {
    local file="$1"
    
    if [[ ! -f "$file" ]] || [[ ! -r "$file" ]]; then
        print_warning "Cannot read file: $file"
        return
    fi
    
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "\n${BOLD}File: ${CYAN}$file${NC}"
    else
        echo -e "\nFile: $file"
    fi
    echo "${DELIMITER}"
    
    local file_content
    file_content=$(cat "$file")
    
    if [[ "$SHOW_LINE_NUMBERS" == true ]]; then
        if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then
            local compressed_content
            compressed_content=$(compress_content "$file_content")
            local line_num=1
            while IFS= read -r line; do
                printf "%6d  %s\n" "$line_num" "$line"
                line_num=$((line_num + 1))
            done <<< "$compressed_content"
        else
            cat -n "$file"
        fi
    elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then
        compress_content "$file_content"
    else
        cat "$file"
    fi
}

# Enhanced process_directory with HEADER_TYPE support
process_directory() {
    local dir="$1"
    local dir_name=$(basename "$dir")
    local is_dir_hidden=false
    [[ "$dir_name" == .* ]] && is_dir_hidden=true
    local force_show_hidden="${2:-false}"
    
    # Skip entire directory if it matches skip patterns
    if should_skip "$dir"; then
        print_info "Skipping entire directory: $dir"
        return
    fi
    
    if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_dir_hidden" == true ]] && [[ "$dir" != "." ]] && [[ ! " ${DIRECTORIES[@]} " =~ " $dir " ]]; then
        return
    fi
    
    # Skip header if HEADER_TYPE is "none"
    if [[ "$HEADER_TYPE" != "none" ]]; then
        if [[ "$WRITING_TO_FILE" == false ]]; then
            echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "${BOLD}Directory Structure:${NC}"
            echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n"
        else
            echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "Directory Structure:"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        fi
        
        # Determine recursion
        local recursive=true
        if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then
            recursive=false
        fi
        
        # Use appropriate header display based on HEADER_TYPE
        case "$HEADER_TYPE" in
            "tree")
                get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden"
                ;;
            "ls"|"ls-R")
                get_ls_structure "$dir" 0 "$recursive" false "$force_show_hidden"
                ;;
            *)
                get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden"
                ;;
        esac
    fi
    
    # Process file contents
    local show_file_contents=false
    if [[ "$INCLUDE_HIDDEN" == true ]] || [[ ${#SKIP_PATTERNS[@]} -gt 0 ]] || \
       [[ ${#OUTPUT_FILES[@]} -gt 0 ]] || [[ "$COMPRESS" == true ]] || \
       [[ "$SHOW_LINE_NUMBERS" == true ]]; then
        show_file_contents=true
    fi
    
    if [[ ${#VALID_DIRECTORIES[@]} -gt 1 ]] || [[ ${#VALID_FILES[@]} -gt 0 ]]; then
        show_file_contents=true
    fi
    
    if [[ "$show_file_contents" == true ]]; then
        if [[ "$WRITING_TO_FILE" == false ]]; then
            echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
            echo -e "${BOLD}File Contents:${NC}"
            echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}"
        else
            echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            echo "File Contents:"
            echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        fi
        
        local find_cmd="find \"$dir\" -type f"
        
        # Apply recursion limit for non-recursive mode
        if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then
            find_cmd="$find_cmd -maxdepth 1"
        fi
        
        if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then
            if [[ "$is_dir_hidden" == true ]]; then
                find_cmd="$find_cmd -not -name '.*'"
            else
                find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\""
            fi
        fi
        
        find_cmd="$find_cmd | sort"
        local file_count=0
        while IFS= read -r file; do
            [[ -z "$file" ]] && continue
            if should_skip "$file"; then continue; fi
            local file_name=$(basename "$file")
            if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$file_name" == .* ]]; then continue; fi
            
            process_file_content "$file"
            file_count=$((file_count + 1))
        done < <(eval "$find_cmd 2>/dev/null")
        
        if [[ $file_count -eq 0 ]]; then
            echo -e "\nNo files found to process in this directory."
        else
            echo -e "\nProcessed $file_count files from $dir"
        fi
    fi
}

# Process single file
process_single_file() {
    local file="$1"
    if should_skip "$file"; then
        print_warning "Skipping file: $file"
        return
    fi
    print_info "Processing single file: $file"
    if [[ "$WRITING_TO_FILE" == false ]]; then
        echo -e "${BOLD}File: ${CYAN}$file${NC}"
    else
        echo "File: $file"
    fi
    echo "${DELIMITER}"
    local file_content=$(cat "$file")
    if [[ "$SHOW_LINE_NUMBERS" == true ]]; then
        if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then
            local compressed_content=$(compress_content "$file_content")
            local line_num=1
            while IFS= read -r line; do
                printf "%6d  %s\n" "$line_num" "$line"
                line_num=$((line_num + 1))
            done <<< "$compressed_content"
        else
            cat -n "$file"
        fi
    elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then
        compress_content "$file_content"
    else
        cat "$file"
    fi
}

# =============================================================================
# Main Argument Parsing
# =============================================================================

# Handle install flag separately
if [[ $# -eq 1 ]] && ([[ "$1" == "-i" ]] || [[ "$1" == "--install" ]]); then
    install_lscat
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help) print_help; exit 0 ;;
        -v|--version) print_version; exit 0 ;;
        -d|--dir) 
            shift
            # Collect all non-option arguments
            while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do 
                DIRECTORIES+=("$1")
                shift
            done
            continue 
            ;;
        -f|--file) 
            shift
            # Collect all non-option arguments
            while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do 
                FILES+=("$1")
                shift
            done
            continue 
            ;;
        -s|--skip) 
            shift
            # Collect all non-option arguments
            while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do 
                SKIP_PATTERNS+=("$1")
                shift
            done
            continue 
            ;;
        -a|--all) INCLUDE_HIDDEN=true ;;
        -D|--destination) 
            shift
            # Collect all non-option arguments
            while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do 
                OUTPUT_FILES+=("$1")
                shift
            done
            continue 
            ;;
        -de|--delimiter) 
            shift
            if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then 
                DELIMITER="$1"
                shift
            else 
                print_error "Delimiter requires a value"
                exit 1
            fi 
            ;;
        -c|--compress) COMPRESS=true ;;
        -C|--compress-hard) COMPRESS_HARD=true; COMPRESS=true ;;
        -l|--line-numbers) SHOW_LINE_NUMBERS=true ;;
        -H|--header-type)
            shift
            if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then 
                HEADER_TYPE="$1"
                shift
                # Validate header type
                case "$HEADER_TYPE" in
                    "tree"|"ls"|"ls-R"|"none")
                        # Valid, do nothing
                        ;;
                    *)
                        print_error "Invalid header type: $HEADER_TYPE. Use tree, ls, ls-R, or none"
                        exit 1
                        ;;
                esac
            else 
                print_error "Header type requires a value: tree, ls, ls-R, or none"
                exit 1
            fi 
            ;;
        -i|--install) print_error "Install option (-i/--install) cannot be combined with other options"; exit 1 ;;
        -*) print_error "Unknown option: $1"; exit 1 ;;
        *) 
            # Positional arguments are no longer supported
            print_error "Positional arguments are not supported. Use -d for directories or -f for files."
            print_error "Example: lscat -d .    or    lscat -f *.md"
            exit 1
            ;;
    esac
    shift
done

# Handle default case (no arguments)
if [[ ${#DIRECTORIES[@]} -eq 0 ]] && [[ ${#FILES[@]} -eq 0 ]]; then
    DIRECTORIES=(".")
    POSITIONAL_DIRECTORIES=true
fi

# Debug: show what we received
# echo "DEBUG: Raw DIRECTORIES: ${DIRECTORIES[@]}" >&2
# echo "DEBUG: Raw FILES: ${FILES[@]}" >&2
# echo "DEBUG: Raw SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2

# Expand patterns in all arrays that support them
if [[ ${#DIRECTORIES[@]} -gt 0 ]]; then
    # Create temporary array for expanded directories
    local temp_dirs=()
    for dir in "${DIRECTORIES[@]}"; do
        # Use mapfile to handle multi-line output from expand_patterns
        while IFS= read -r expanded_item; do
            if [[ -n "$expanded_item" ]]; then
                temp_dirs+=("$expanded_item")
            fi
        done < <(expand_patterns "$dir")
    done
    # Update DIRECTORIES with expanded items
    DIRECTORIES=("${temp_dirs[@]}")
fi

if [[ ${#FILES[@]} -gt 0 ]]; then
    # Create temporary array for expanded files
    local temp_files=()
    for file in "${FILES[@]}"; do
        # Use mapfile to handle multi-line output from expand_file_patterns
        while IFS= read -r expanded_item; do
            if [[ -n "$expanded_item" ]]; then
                temp_files+=("$expanded_item")
            fi
        done < <(expand_file_patterns "$file")
    done
    # Update FILES with expanded items
    FILES=("${temp_files[@]}")
fi

if [[ ${#SKIP_PATTERNS[@]} -gt 0 ]]; then
    # Create temporary array for expanded skip patterns
    local temp_skips=()
    for pattern in "${SKIP_PATTERNS[@]}"; do
        # Use mapfile to handle multi-line output from expand_patterns
        while IFS= read -r expanded_item; do
            if [[ -n "$expanded_item" ]]; then
                temp_skips+=("$expanded_item")
            fi
        done < <(expand_patterns "$pattern")
    done
    # Update SKIP_PATTERNS with expanded items
    SKIP_PATTERNS=("${temp_skips[@]}")
fi

# Debug: show what we expanded to
# echo "DEBUG: Expanded DIRECTORIES: ${DIRECTORIES[@]}" >&2
# echo "DEBUG: Expanded FILES: ${FILES[@]}" >&2
# echo "DEBUG: Expanded SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2

# Set flags based on the directory specification
if [[ " ${DIRECTORIES[@]} " =~ " . " ]] && [[ ${#DIRECTORIES[@]} -eq 1 ]]; then
    if [[ "$POSITIONAL_DIRECTORIES" == true ]]; then
        # lscat or lscat . (positional) - non-recursive, show hidden
        NON_RECURSIVE=true
    elif [[ "$INCLUDE_HIDDEN" == true ]]; then
        # lscat -d . -a - non-recursive, show hidden
        NON_RECURSIVE=true
    else
        # lscat -d . (without -a) - non-recursive, hide hidden
        NON_RECURSIVE=true
    fi
fi

VALID_DIRECTORIES=()
VALID_FILES=()

# Validate directories
for dir in "${DIRECTORIES[@]}"; do
    if [[ -d "$dir" ]]; then
        VALID_DIRECTORIES+=("$dir")
    elif [[ -f "$dir" ]]; then
        print_warning "Directory expected but found file in -d flag: $dir (use -f for files)"
    else
        print_error "Directory not found: $dir"
    fi
done

# Validate files
for file in "${FILES[@]}"; do
    if [[ -f "$file" ]]; then
        VALID_FILES+=("$file")
    elif [[ -d "$file" ]]; then
        print_warning "File expected but found directory in -f flag: $file (use -d for directories)"
    else
        print_warning "File not found: $file (skipping)"
    fi
done

# Process output
if [[ ${#OUTPUT_FILES[@]} -gt 0 ]]; then
    WRITING_TO_FILE=true
    for output_file in "${OUTPUT_FILES[@]}"; do
        print_info "Output will be saved to: $output_file"
        > "$output_file"
        for dir in "${VALID_DIRECTORIES[@]}"; do 
            if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then
                # Positional . shows hidden
                process_directory "$dir" true >> "$output_file"
            else
                # -d specified, use normal behavior
                process_directory "$dir" false >> "$output_file"
            fi
        done
        for file in "${VALID_FILES[@]}"; do 
            process_single_file "$file" >> "$output_file"
        done
    done
    print_info "Output saved to specified file(s)"
else
    for dir in "${VALID_DIRECTORIES[@]}"; do
        if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then
            # Positional . shows hidden
            process_directory "$dir" true
        else
            # -d specified, use normal behavior
            process_directory "$dir" false
        fi
    done
    for file in "${VALID_FILES[@]}"; do 
        process_single_file "$file"
    done
fi
