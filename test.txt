
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Directory Structure:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
File Contents:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

File: ./LICENSE
---
MIT License Copyright (c) 2023 [LIONEL SISSO] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

File: ./lscat
---
#!/bin/bash # ============================================================================= # lscat - List and concatenate directory/file contents with advanced options # Version: 1.5.0 (Added header-type option) # License: MIT - See LICENSE file for details # Repository: https://github.com/yourusername/lscat # ============================================================================= VERSION="1.5.0" SCRIPT_NAME=$(basename "$0") # Default values DELIMITER="---" INCLUDE_HIDDEN=false COMPRESS=false COMPRESS_HARD=false SHOW_LINE_NUMBERS=false OUTPUT_FILES=() SKIP_PATTERNS=() DIRECTORIES=() FILES=() CURRENT_DIR_ONLY=false NON_RECURSIVE=false POSITIONAL_DIRECTORIES=false # Flag to track if dirs were positional HEADER_TYPE="tree" # tree, ls, ls-R # ANSI color codes for better output (will be disabled when outputting to file) RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' MAGENTA='\033[0;35m' CYAN='\033[0;36m' NC='\033[0m' # No Color BOLD='\033[1m' # Flag to track if we're writing to file (so we can disable colors) WRITING_TO_FILE=false # ============================================================================= # Helper Functions # ============================================================================= print_help() { # Plain text help (no ANSI codes) echo "lscat - List and Concatenate Tool" echo "Version: $VERSION" echo "" echo "DESCRIPTION:" echo " Recursively lists directory structure and concatenates file contents with" echo " customizable delimiters. Useful for AI analysis, documentation, or bulk" echo " file processing." echo "" echo "USAGE:" echo " $SCRIPT_NAME [OPTIONS]" echo "" echo " Files and directories must be specified with -f or -d flags" echo "" echo "OPTIONS:" echo " -d, --dir DIR1 [DIR2...] Directories to process recursively" echo " -d * : All non-hidden directories recursively" echo " -d . : Current directory only (non-recursive)" echo " Supports patterns: *, .*, migration*/" echo " -f, --file FILE1 [FILE2...] Files to process (non-recursive only)" echo " -f * : All non-hidden files in current directory" echo " -f .* : All hidden files in current directory" echo " Supports patterns: *.md, *.js, etc." echo " Can specify full paths: -f client/src/app.js" echo " -s, --skip PATTERN Skip files/dirs matching pattern (can use multiple)" echo " Patterns match at any directory level" echo " Example: -s node_modules skips ALL node_modules dirs" echo " -a, --all Include hidden files and directories" echo " -D, --destination FILE Output file(s) (creates if doesn't exist)" echo " -de, --delimiter CHAR Delimiter between file contents (default: \"---\")" echo " -c, --compress Compress content (remove indentation and blank lines)" echo " -C, --compress-hard Aggressive compression (remove all formatting, one-line per file)" echo " -l, --line-numbers Show line numbers in file contents" echo " -H, --header-type TYPE Change header display style: tree (default), ls, ls-R" echo " tree: Full tree structure with branches" echo " ls: Simple ls-style list (compact)" echo " ls-R: Recursive ls-style list with subdir levels" echo " -i, --install Install lscat system-wide (standalone option)" echo " -h, --help Show this help message" echo " -v, --version Show version information" echo "" echo "BEHAVIOR:" echo " lscat # Non-recursive tree of current dir (shows hidden)" echo " lscat -d . # Same as above (explicit)" echo " lscat -d * # All directories recursively" echo " lscat -f * # All files in current directory (non-recursive)" echo "" echo "PATTERN EXAMPLES:" echo " lscat -d \"*\" # All non-hidden directories recursively" echo " lscat -d \"*\" -a # All directories (including hidden) recursively" echo " lscat -d . -a # Current directory only (including hidden)" echo " lscat -f '*.md' # All .md files in current directory" echo " lscat -f \".*\" # All hidden files in current directory" echo " lscat -f 'client/src/*.js' # All .js files in client/src" echo " lscat -d 'server/database/migration*/' # All migration directories" echo " lscat -s '*.log' # Skip all .log files" echo " lscat -s .git -s node_modules # Skip .git and node_modules directories" echo " lscat -s ./client/node_modules/ # Skip specific directory path" echo "" echo "HEADER TYPE EXAMPLES:" echo " lscat -d . -H tree # Default tree structure (verbose)" echo " lscat -d . -H ls # Compact ls-style listing" echo " lscat -d . -H ls-R # Recursive ls-style listing" echo " lscat -d * -c -H ls # Compact headers with compressed content" echo " lscat -d * -C -H ls # Hard compression with compact headers" echo "" echo "EXAMPLES:" echo " $SCRIPT_NAME # Non-recursive list of current directory" echo " $SCRIPT_NAME -d \"*\" -a -s .* # All non-hidden recursively (skip hidden)" echo " $SCRIPT_NAME -D output.txt -de \"***\" # Use custom delimiter, output to file" echo " $SCRIPT_NAME -a -c -l # Include hidden files, compress, line numbers" echo " $SCRIPT_NAME -f *.md -d client server # Process .md files and client/server directories" echo " $SCRIPT_NAME -f .gitignore readme.md -d src # Mix specific files and directories" echo "" echo "NOTES:" echo " - Use quotes around patterns to prevent shell expansion" echo " - Skip patterns prevent BOTH tree display AND file processing" echo " - Skip patterns match at any depth (e.g., -s node_modules skips all node_modules)" echo " - -d flag is for directories only (recursive with *)" echo " - -f flag is for files only (non-recursive, current directory only)" echo " - -H flag reduces header size when combining -d with -C or -c" echo " - Default (no flags): non-recursive tree of current dir, shows hidden" } print_version() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}lscat${NC} version ${GREEN}$VERSION${NC}" echo "Created for efficient file concatenation and AI processing" else echo "lscat version $VERSION" echo "Created for efficient file concatenation and AI processing" fi } print_error() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${RED}Error:${NC} $1" >&2 else echo "Error: $1" >&2 fi } print_warning() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}Warning:${NC} $1" >&2 else echo "Warning: $1" >&2 fi } print_info() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${CYAN}Info:${NC} $1" else echo "Info: $1" fi } # Installation function install_lscat() { echo "Installing lscat..." echo "=====================" # Get the script's own location if [[ -f "$0" ]]; then SCRIPT_PATH="$0" else # Fallback to the current script SCRIPT_PATH="./$(basename "$0")" fi if [[ ! -f "$SCRIPT_PATH" ]]; then print_error "Cannot find lscat script to install" exit 1 fi # Make sure the script is executable chmod +x "$SCRIPT_PATH" 2>/dev/null || true echo "" echo "Select installation method:" echo "1) Current user only (~/.local/bin) - Recommended" echo "2) System-wide (/usr/local/bin) - Requires sudo" echo "3) System-wide (/usr/bin) - Requires sudo" echo "4) Custom location with symlink" echo "5) Cancel installation" echo "" read -p "Enter choice [1-5]: " choice case $choice in 1) # User installation mkdir -p ~/.local/bin if cp "$SCRIPT_PATH" ~/.local/bin/lscat; then chmod +x ~/.local/bin/lscat echo "Installed to ~/.local/bin/lscat" # Check if PATH needs update if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then echo "Adding ~/.local/bin to PATH..." echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc 2>/dev/null || true source ~/.bashrc 2>/dev/null || true fi else print_error "Failed to copy to ~/.local/bin/" exit 1 fi ;; 2) # System installation to /usr/local/bin if sudo cp "$SCRIPT_PATH" /usr/local/bin/lscat; then sudo chmod +x /usr/local/bin/lscat echo "Installed to /usr/local/bin/lscat" else print_error "Failed to install to /usr/local/bin" exit 1 fi ;; 3) # System installation to /usr/bin if sudo cp "$SCRIPT_PATH" /usr/bin/lscat; then sudo chmod +x /usr/bin/lscat echo "Installed to /usr/bin/lscat" else print_error "Failed to install to /usr/bin" exit 1 fi ;; 4) # Custom symlink method read -p "Enter installation directory (e.g., /opt/lscat): " install_dir if [[ -z "$install_dir" ]]; then print_error "No directory specified" exit 1 fi mkdir -p "$install_dir" 2>/dev/null || sudo mkdir -p "$install_dir" if cp "$SCRIPT_PATH" "$install_dir/lscat"; then chmod +x "$install_dir/lscat" read -p "Create symlink in which directory? (e.g., /usr/local/bin): " symlink_dir if [[ -n "$symlink_dir" ]]; then sudo ln -sf "$install_dir/lscat" "$symlink_dir/lscat" 2>/dev/null || ln -sf "$install_dir/lscat" "$symlink_dir/lscat" echo "Installed to $install_dir/lscat with symlink in $symlink_dir" else echo "Installed to $install_dir/lscat (no symlink created)" fi else print_error "Failed to install to $install_dir" exit 1 fi ;; 5) echo "Installation cancelled." exit 0 ;; *) print_error "Invalid choice!" exit 1 ;; esac # Verify installation echo "" echo "Verifying installation..." if command -v lscat &> /dev/null; then echo -e "\033[32m‚úì lscat installed successfully!\033[0m" echo "Run 'lscat --help' to see usage" else echo -e "\033[31m‚úó Installation completed but lscat not found in PATH\033[0m" echo "You may need to log out and back in, or run: source ~/.bashrc" fi exit 0 } # Enhanced pattern expansion function (DIRECTORIES ONLY - recursive) expand_patterns() { local items=("$@") local expanded_items=() for item in "${items[@]}"; do # Special cases if [[ "$item" == "*" ]]; then # * means all non-hidden directories recursively if [[ "$INCLUDE_HIDDEN" == true ]]; then # Include hidden directories while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -print0 2>/dev/null) else # Exclude hidden directories while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]] && [[ ! "$found_item" =~ /\. ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -not -name '.*' -print0 2>/dev/null) fi elif [[ "$item" == "." ]] && [[ "$POSITIONAL_DIRECTORIES" == false ]]; then # . with -d flag means current directory only (non-recursive) expanded_items+=(".") elif [[ "$item" == ".*" ]]; then # .* means hidden directories recursively while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -name '.*' -print0 2>/dev/null) elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then # Contains wildcard pattern - directories only # First, check if it's a literal directory that exists if [[ -d "$item" ]]; then # It exists as a literal directory expanded_items+=("$item") else # Try to expand with shell globbing (with nullglob to avoid literal pattern) shopt -s nullglob local found_items=() # Try with current directory if no directory specified if [[ "$item" != */* ]] && [[ "$item" != ./* ]]; then # Pattern without path - try in current directory for found_item in ./$item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done fi # Try the pattern as-is for found_item in $item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done shopt -u nullglob if [[ ${#found_items[@]} -eq 0 ]]; then # If no matches with shell globbing, try find for more complex patterns local pattern_name=$(basename "$item") local pattern_dir=$(dirname "$item") [[ "$pattern_dir" == "." ]] && pattern_dir="." # Handle directory patterns like migration*/ if [[ "$item" == */ ]]; then # Directory pattern while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null) else # General pattern (directories only) while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null) fi fi # Add found items for found_item in "${found_items[@]}"; do expanded_items+=("$found_item") done fi else # No pattern, check if it's a directory if [[ -d "$item" ]]; then expanded_items+=("$item") elif [[ -e "$item" ]]; then print_warning "Skipping non-directory item in -d flag: $item" else print_error "Directory not found: $item" return 1 fi fi done # Remove duplicates and empty entries local unique_items=() for item in "${expanded_items[@]}"; do if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then unique_items+=("$item") fi done # Output each item on a new line for item in "${unique_items[@]}"; do echo "$item" done } # Enhanced file pattern expansion function (FILES ONLY - non-recursive) expand_file_patterns() { local items=("$@") local expanded_items=() for item in "${items[@]}"; do # Special cases if [[ "$item" == "*" ]]; then # * means all non-hidden files in current directory (non-recursive) if [[ "$INCLUDE_HIDDEN" == true ]]; then # Include hidden files while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -print0 2>/dev/null) else # Exclude hidden files while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -not -name '.*' -print0 2>/dev/null) fi elif [[ "$item" == ".*" ]]; then # .* means hidden files in current directory while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -name '.*' -print0 2>/dev/null) elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then # Contains wildcard pattern - files only, non-recursive local pattern_name=$(basename "$item") local pattern_dir=$(dirname "$item") [[ "$pattern_dir" == "." ]] && pattern_dir="." if [[ -d "$pattern_dir" ]] || [[ "$pattern_dir" == "" ]]; then # Use find with maxdepth 1 for non-recursive search if [[ "$INCLUDE_HIDDEN" == true ]]; then while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -print0 2>/dev/null) else while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]] && [[ ! "$(basename "$found_item")" == .* ]]; then expanded_items+=("$found_item") fi done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -not -name '.*' -print0 2>/dev/null) fi fi else # No pattern, check if it's a file if [[ -f "$item" ]]; then expanded_items+=("$item") elif [[ -e "$item" ]]; then print_warning "Skipping non-file item in -f flag: $item" else print_warning "File not found: $item" fi fi done # Remove duplicates and empty entries local unique_items=() for item in "${expanded_items[@]}"; do if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then unique_items+=("$item") fi done # Output each item on a new line for item in "${unique_items[@]}"; do echo "$item" done } # Enhanced should_skip with better directory handling should_skip() { local item="$1" local item_name=$(basename "$item") for pattern in "${SKIP_PATTERNS[@]}"; do # Remove trailing / if present pattern="${pattern%/}" # Skip empty patterns [[ -z "$pattern" ]] && continue # 1. Check exact match if [[ "$item" == "$pattern" ]] || [[ "$item_name" == "$pattern" ]]; then return 0 fi # 2. Check if pattern contains wildcards if [[ "$pattern" == *"*"* ]] || [[ "$pattern" == *"?"* ]] || [[ "$pattern" == *"["* ]]; then # Use case pattern matching case "$item" in $pattern) return 0 ;; esac case "$item_name" in $pattern) return 0 ;; esac fi # 3. Check for directory path matching (e.g., ./client/node_modules) # Remove leading ./ if present for better matching local clean_pattern="${pattern#./}" local clean_item="${item#./}" if [[ "$clean_item" == "$clean_pattern"* ]]; then # If pattern ends with a directory name and item is under that directory return 0 fi # 4. Check if item is inside a skipped directory # For each segment of the item path, check if it matches a skip pattern local temp_path="$clean_item" while [[ "$temp_path" != "." ]] && [[ "$temp_path" != "" ]]; do local current_dir="$(basename "$temp_path")" if [[ "$current_dir" == "$clean_pattern" ]] || [[ "$current_dir" == "$pattern" ]] || ([[ "$pattern" == *"*"* ]] && case "$current_dir" in $pattern) true;; *) false;; esac); then return 0 fi temp_path="$(dirname "$temp_path")" if [[ "$temp_path" == "/" ]] || [[ "$temp_path" == "." ]]; then break fi done done return 1 } # Normal compression - remove indentation and blank lines compress_content() { local content="$1" if [[ "$COMPRESS" == false ]] && [[ "$COMPRESS_HARD" == false ]]; then echo "$content" return fi # If hard compression is enabled, use that instead if [[ "$COMPRESS_HARD" == true ]]; then compress_hard_content "$content" return fi # Original compression: remove leading/trailing whitespace and empty lines echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d' } # Hard compression - remove ALL formatting, make each file one continuous line compress_hard_content() { local content="$1" # First, remove all trailing/leading whitespace from each line content=$(echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//') # Remove completely empty lines content=$(echo "$content" | sed -e '/^$/d') # Join lines with a single space, but be careful with certain patterns local result="" local in_multiline_comment=false local in_string=false local string_char="" # FIX: Define regex variables to avoid syntax errors with < > characters in conditionals local regex_open='[\({\[<]' local regex_close='[.,;:!?\)}\]>]' while IFS= read -r line; do # Skip empty lines [[ -z "$line" ]] && continue # Handle multiline comments if [[ "$in_multiline_comment" == true ]]; then if [[ "$line" == *"*/"* ]]; then in_multiline_comment=false fi result="${result}${line} " continue fi # Check if line starts a multiline comment if [[ "$line" == "/*"* ]] && [[ "$line" != *"*/"* ]]; then in_multiline_comment=true result="${result}${line} " continue fi if [[ -n "$result" ]]; then local last_char="${result: -1}" local first_char="${line:0:1}" # Use defined variables for pattern matching if [[ "$last_char" =~ $regex_open ]] || [[ "$first_char" =~ $regex_close ]]; then result="${result}${line} " else result="${result} ${line} " fi else result="${line} " fi done <<< "$content" # Clean up: remove trailing space and collapse multiple spaces result=$(echo "$result" | sed -e 's/[[:space:]]*$//' -e 's/[[:space:]]\+/ /g') if [[ ${#result} -gt 1000 ]] && [[ "$WRITING_TO_FILE" == false ]]; then print_warning "Hard compression created very long line (${#result} chars)" fi echo "$result" } # Enhanced get_tree_structure with proper skip handling get_tree_structure() { local dir="$1" local depth="${2:-0}" local prefix="${3:-}" local recursive="${4:-true}" local parent_is_hidden="${5:-false}" local force_show_hidden="${6:-false}" # Apply non-recursive flag if [[ "$NON_RECURSIVE" == true ]]; then recursive=false fi # Skip entire directory if it matches skip patterns if should_skip "$dir"; then if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}üìÅ $dir (skipped)${NC}" else echo "üìÅ $dir (skipped)" fi else echo "${prefix}üìÅ $(basename "$dir")/ (skipped)" fi return fi # Check if current directory is hidden (starts with .) local dir_name=$(basename "$dir") local is_current_hidden=false [[ "$dir_name" == .* ]] && is_current_hidden=true # Determine if we should show this directory if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then return fi # Print current directory if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}${BLUE}üìÅ $dir${NC}" else echo "üìÅ $dir" fi else echo "${prefix}üìÅ $dir_name/" fi # Find items in directory local find_opts="" if [[ "$recursive" == false ]]; then find_opts="-maxdepth 1" fi local find_cmd="find \"$dir\" $find_opts -mindepth 1" if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_current_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" local count=0 local total_items=0 # First, count total items while IFS= read -r item; do [[ -z "$item" ]] && continue total_items=$((total_items + 1)) done < <(eval "$find_cmd 2>/dev/null") # Process items while IFS= read -r item; do [[ -z "$item" ]] && continue local item_name=$(basename "$item") local is_item_hidden=false [[ "$item_name" == .* ]] && is_item_hidden=true # Skip if pattern matches if should_skip "$item"; then continue fi # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then continue fi count=$((count + 1)) # Determine if last item for pretty tree local next_prefix="$prefix" if [[ $count -eq $total_items ]]; then next_prefix="${prefix} " echo -n "${prefix}‚îî‚îÄ‚îÄ " else next_prefix="${prefix}‚îÇ " echo -n "${prefix}‚îú‚îÄ‚îÄ " fi if [[ -d "$item" ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BLUE}$item_name/${NC}" else echo "$item_name/" fi # Only recurse if recursive flag is true and not skipping if [[ "$recursive" == true ]] && ! should_skip "$item"; then get_tree_structure "$item" $((depth + 1)) "$next_prefix" "$recursive" "$is_current_hidden" "$force_show_hidden" fi else # Color code by file extension local ext="${item_name##*.}" if [[ "$WRITING_TO_FILE" == false ]]; then if [[ "$ext" == "$item_name" ]]; then echo -e "${GREEN}$item_name${NC}" elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then echo -e "${MAGENTA}$item_name${NC}" elif [[ "$ext" == "py" ]]; then echo -e "${YELLOW}$item_name${NC}" elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then echo -e "${CYAN}$item_name${NC}" elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then echo -e "${GREEN}$item_name${NC}" else echo "$item_name" fi else echo "$item_name" fi fi done < <(eval "$find_cmd 2>/dev/null") if [[ $count -eq 0 ]]; then echo "${prefix} (empty)" fi } # NEW: Get ls-style structure (compact, no tree branches) get_ls_structure() { local dir="$1" local depth="${2:-0}" local recursive="${3:-true}" local parent_is_hidden="${4:-false}" local force_show_hidden="${5:-false}" # Apply non-recursive flag if [[ "$NON_RECURSIVE" == true ]]; then recursive=false fi # Skip entire directory if it matches skip patterns if should_skip "$dir"; then if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}üìÅ $dir (skipped)${NC}" else echo "üìÅ $dir (skipped)" fi fi return fi # Check if current directory is hidden (starts with .) local dir_name=$(basename "$dir") local is_current_hidden=false [[ "$dir_name" == .* ]] && is_current_hidden=true # Determine if we should show this directory if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then return fi # Print current directory (with indentation for subdirectories in ls-R mode) local indent="" if [[ $depth -gt 0 ]] && [[ "$HEADER_TYPE" == "ls-R" ]]; then for ((i=0; i<depth; i++)); do indent="${indent} " done echo "${indent}$dir/" elif [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}${BLUE}üìÅ $dir${NC}" else echo "üìÅ $dir" fi fi # Find items in directory local find_opts="-maxdepth 1" if [[ "$recursive" == false ]]; then find_opts="-maxdepth 1" fi local find_cmd="find \"$dir\" $find_opts -mindepth 1" if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_current_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" # Process files and directories separately for better organization local files=() local subdirs=() while IFS= read -r item; do [[ -z "$item" ]] && continue local item_name=$(basename "$item") local is_item_hidden=false [[ "$item_name" == .* ]] && is_item_hidden=true # Skip if pattern matches if should_skip "$item"; then continue fi # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then continue fi if [[ -d "$item" ]]; then subdirs+=("$item") else files+=("$item") fi done < <(eval "$find_cmd 2>/dev/null") # Print files first for item in "${files[@]}"; do local item_name=$(basename "$item") local ext="${item_name##*.}" # Add indentation for subdirectories in ls-R mode local item_indent="$indent" if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then item_indent="${item_indent} " fi if [[ "$WRITING_TO_FILE" == false ]]; then if [[ "$ext" == "$item_name" ]]; then echo -e "${item_indent}${GREEN}$item_name${NC}" elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then echo -e "${item_indent}${MAGENTA}$item_name${NC}" elif [[ "$ext" == "py" ]]; then echo -e "${item_indent}${YELLOW}$item_name${NC}" elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then echo -e "${item_indent}${CYAN}$item_name${NC}" elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then echo -e "${item_indent}${GREEN}$item_name${NC}" else echo "${item_indent}$item_name" fi else echo "${item_indent}$item_name" fi done # Print directories for item in "${subdirs[@]}"; do local item_name=$(basename "$item") local item_indent="$indent" if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then item_indent="${item_indent} " fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${item_indent}${BLUE}$item_name/${NC}" else echo "${item_indent}$item_name/" fi # Recurse into subdirectories if recursive flag is true and not skipping if [[ "$recursive" == true ]] && [[ "$HEADER_TYPE" == "ls-R" ]] && ! should_skip "$item"; then get_ls_structure "$item" $((depth + 1)) "$recursive" "$is_current_hidden" "$force_show_hidden" fi done # Print empty message if no items if [[ ${#files[@]} -eq 0 ]] && [[ ${#subdirs[@]} -eq 0 ]]; then if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then echo "${indent} (empty)" else echo " (empty)" fi fi # Add a blank line between directories in ls-R mode for readability if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -eq 0 ]] && [[ ${#subdirs[@]} -gt 0 ]]; then echo "" fi } # Process file content with options process_file_content() { local file="$1" if [[ ! -f "$file" ]] || [[ ! -r "$file" ]]; then print_warning "Cannot read file: $file" return fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}File: ${CYAN}$file${NC}" else echo -e "\nFile: $file" fi echo "${DELIMITER}" local file_content file_content=$(cat "$file") if [[ "$SHOW_LINE_NUMBERS" == true ]]; then if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then local compressed_content compressed_content=$(compress_content "$file_content") local line_num=1 while IFS= read -r line; do printf "%6d %s\n" "$line_num" "$line" line_num=$((line_num + 1)) done <<< "$compressed_content" else cat -n "$file" fi elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then compress_content "$file_content" else cat "$file" fi } # Enhanced process_directory with HEADER_TYPE support process_directory() { local dir="$1" local dir_name=$(basename "$dir") local is_dir_hidden=false [[ "$dir_name" == .* ]] && is_dir_hidden=true local force_show_hidden="${2:-false}" # Skip entire directory if it matches skip patterns if should_skip "$dir"; then print_info "Skipping entire directory: $dir" return fi if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_dir_hidden" == true ]] && [[ "$dir" != "." ]] && [[ ! " ${DIRECTORIES[@]} " =~ " $dir " ]]; then return fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" echo -e "${BOLD}Directory Structure:${NC}" echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n" else echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" echo "Directory Structure:" echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n" fi # Determine recursion local recursive=true if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then recursive=false fi # Use appropriate header display based on HEADER_TYPE case "$HEADER_TYPE" in "tree") get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden" ;; "ls"|"ls-R") get_ls_structure "$dir" 0 "$recursive" false "$force_show_hidden" ;; *) get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden" ;; esac # Process file contents local show_file_contents=false if [[ "$INCLUDE_HIDDEN" == true ]] || [[ ${#SKIP_PATTERNS[@]} -gt 0 ]] || \ [[ ${#OUTPUT_FILES[@]} -gt 0 ]] || [[ "$COMPRESS" == true ]] || \ [[ "$SHOW_LINE_NUMBERS" == true ]]; then show_file_contents=true fi if [[ ${#VALID_DIRECTORIES[@]} -gt 1 ]] || [[ ${#VALID_FILES[@]} -gt 0 ]]; then show_file_contents=true fi if [[ "$show_file_contents" == true ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" echo -e "${BOLD}File Contents:${NC}" echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" else echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" echo "File Contents:" echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" fi local find_cmd="find \"$dir\" -type f" # Apply recursion limit for non-recursive mode if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then find_cmd="$find_cmd -maxdepth 1" fi if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_dir_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" local file_count=0 while IFS= read -r file; do [[ -z "$file" ]] && continue if should_skip "$file"; then continue; fi local file_name=$(basename "$file") if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$file_name" == .* ]]; then continue; fi process_file_content "$file" file_count=$((file_count + 1)) done < <(eval "$find_cmd 2>/dev/null") if [[ $file_count -eq 0 ]]; then echo -e "\nNo files found to process in this directory." else echo -e "\nProcessed $file_count files from $dir" fi fi } # Process single file process_single_file() { local file="$1" if should_skip "$file"; then print_warning "Skipping file: $file" return fi print_info "Processing single file: $file" if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}File: ${CYAN}$file${NC}" else echo "File: $file" fi echo "${DELIMITER}" local file_content=$(cat "$file") if [[ "$SHOW_LINE_NUMBERS" == true ]]; then if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then local compressed_content=$(compress_content "$file_content") local line_num=1 while IFS= read -r line; do printf "%6d %s\n" "$line_num" "$line" line_num=$((line_num + 1)) done <<< "$compressed_content" else cat -n "$file" fi elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then compress_content "$file_content" else cat "$file" fi } # ============================================================================= # Main Argument Parsing # ============================================================================= # Handle install flag separately if [[ $# -eq 1 ]] && ([[ "$1" == "-i" ]] || [[ "$1" == "--install" ]]); then install_lscat fi # Parse arguments while [[ $# -gt 0 ]]; do case $1 in -h|--help) print_help; exit 0 ;; -v|--version) print_version; exit 0 ;; -d|--dir) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do DIRECTORIES+=("$1") shift done continue ;; -f|--file) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do FILES+=("$1") shift done continue ;; -s|--skip) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do SKIP_PATTERNS+=("$1") shift done continue ;; -a|--all) INCLUDE_HIDDEN=true ;; -D|--destination) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do OUTPUT_FILES+=("$1") shift done continue ;; -de|--delimiter) shift if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then DELIMITER="$1" shift else print_error "Delimiter requires a value" exit 1 fi ;; -c|--compress) COMPRESS=true ;; -C|--compress-hard) COMPRESS_HARD=true; COMPRESS=true ;; -l|--line-numbers) SHOW_LINE_NUMBERS=true ;; -H|--header-type) shift if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then HEADER_TYPE="$1" shift # Validate header type case "$HEADER_TYPE" in "tree"|"ls"|"ls-R") # Valid, do nothing ;; *) print_error "Invalid header type: $HEADER_TYPE. Use tree, ls, or ls-R" exit 1 ;; esac else print_error "Header type requires a value: tree, ls, or ls-R" exit 1 fi ;; -i|--install) print_error "Install option (-i/--install) cannot be combined with other options"; exit 1 ;; -*) print_error "Unknown option: $1"; exit 1 ;; *) # Positional arguments are no longer supported print_error "Positional arguments are not supported. Use -d for directories or -f for files." print_error "Example: lscat -d . or lscat -f *.md" exit 1 ;; esac shift done # Handle default case (no arguments) if [[ ${#DIRECTORIES[@]} -eq 0 ]] && [[ ${#FILES[@]} -eq 0 ]]; then DIRECTORIES=(".") POSITIONAL_DIRECTORIES=true fi # Debug: show what we received # echo "DEBUG: Raw DIRECTORIES: ${DIRECTORIES[@]}" >&2 # echo "DEBUG: Raw FILES: ${FILES[@]}" >&2 # echo "DEBUG: Raw SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2 # Expand patterns in all arrays that support them if [[ ${#DIRECTORIES[@]} -gt 0 ]]; then # Create temporary array for expanded directories local temp_dirs=() for dir in "${DIRECTORIES[@]}"; do # Use mapfile to handle multi-line output from expand_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_dirs+=("$expanded_item") fi done < <(expand_patterns "$dir") done # Update DIRECTORIES with expanded items DIRECTORIES=("${temp_dirs[@]}") fi if [[ ${#FILES[@]} -gt 0 ]]; then # Create temporary array for expanded files local temp_files=() for file in "${FILES[@]}"; do # Use mapfile to handle multi-line output from expand_file_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_files+=("$expanded_item") fi done < <(expand_file_patterns "$file") done # Update FILES with expanded items FILES=("${temp_files[@]}") fi if [[ ${#SKIP_PATTERNS[@]} -gt 0 ]]; then # Create temporary array for expanded skip patterns local temp_skips=() for pattern in "${SKIP_PATTERNS[@]}"; do # Use mapfile to handle multi-line output from expand_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_skips+=("$expanded_item") fi done < <(expand_patterns "$pattern") done # Update SKIP_PATTERNS with expanded items SKIP_PATTERNS=("${temp_skips[@]}") fi # Debug: show what we expanded to # echo "DEBUG: Expanded DIRECTORIES: ${DIRECTORIES[@]}" >&2 # echo "DEBUG: Expanded FILES: ${FILES[@]}" >&2 # echo "DEBUG: Expanded SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2 # Set flags based on the directory specification if [[ " ${DIRECTORIES[@]} " =~ " . " ]] && [[ ${#DIRECTORIES[@]} -eq 1 ]]; then if [[ "$POSITIONAL_DIRECTORIES" == true ]]; then # lscat or lscat . (positional) - non-recursive, show hidden NON_RECURSIVE=true elif [[ "$INCLUDE_HIDDEN" == true ]]; then # lscat -d . -a - non-recursive, show hidden NON_RECURSIVE=true else # lscat -d . (without -a) - non-recursive, hide hidden NON_RECURSIVE=true fi fi VALID_DIRECTORIES=() VALID_FILES=() # Validate directories for dir in "${DIRECTORIES[@]}"; do if [[ -d "$dir" ]]; then VALID_DIRECTORIES+=("$dir") elif [[ -f "$dir" ]]; then print_warning "Directory expected but found file in -d flag: $dir (use -f for files)" else print_error "Directory not found: $dir" fi done # Validate files for file in "${FILES[@]}"; do if [[ -f "$file" ]]; then VALID_FILES+=("$file") elif [[ -d "$file" ]]; then print_warning "File expected but found directory in -f flag: $file (use -d for directories)" else print_warning "File not found: $file (skipping)" fi done # Process output if [[ ${#OUTPUT_FILES[@]} -gt 0 ]]; then WRITING_TO_FILE=true for output_file in "${OUTPUT_FILES[@]}"; do print_info "Output will be saved to: $output_file" > "$output_file" for dir in "${VALID_DIRECTORIES[@]}"; do if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then # Positional . shows hidden process_directory "$dir" true >> "$output_file" else # -d specified, use normal behavior process_directory "$dir" false >> "$output_file" fi done for file in "${VALID_FILES[@]}"; do process_single_file "$file" >> "$output_file" done done print_info "Output saved to specified file(s)" else for dir in "${VALID_DIRECTORIES[@]}"; do if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then # Positional . shows hidden process_directory "$dir" true else # -d specified, use normal behavior process_directory "$dir" false fi done for file in "${VALID_FILES[@]}"; do process_single_file "$file" done fi

File: ./readme.md
---
# lscat - Advanced List and Concatenate Tool `lscat` is a powerful command-line utility that combines directory listing with file concatenation capabilities, designed for AI analysis, documentation generation, and bulk file processing. ![Version](https://img.shields.io/badge/version-1.4.0-blue) ![Shell](https://img.shields.io/badge/shell-bash-green) ![License](https://img.shields.io/badge/license-MIT-green) ## ‚ú® Features - **Beautiful tree structure** display with color-coded file types - **Pattern matching** for directories (`-d`) and files (`-f`) with separate controls - **Flexible recursion control** - `-d` for recursive directory traversal, `-f` for non-recursive file selection - **Content concatenation** with customizable delimiters - **Compression options** for AI token optimization - **Hidden file control** with granular visibility options - **Output to file** with automatic color disabling - **Advanced skip patterns** for precise file/directory exclusion - **Line numbering** for code analysis - **Easy installation** with system-wide setup option ## üì¶ Installation ### Quick Install ```bash # Download and install git clone https://github.com/lionel-hue/LSCAT cd LSCAT chmod +x lscat ./lscat -i ``` Choose from these installation methods: 1. **User installation** (~/.local/bin) - Recommended 2. **System-wide** (/usr/local/bin) - Requires sudo 3. **System-wide** (/usr/bin) - Requires sudo 4. **Custom location** with symlink ## üöÄ Usage ### Basic Examples ```bash # Show beautiful tree of current directory (non-recursive, shows hidden) lscat # Process directories recursively lscat -d * # Process files in current directory only lscat -f * # Process specific directories lscat -d client server # Process specific files lscat -f .gitignore README.md package.json # Mix files and directories lscat -f *.md -d src tests ``` ### Pattern Examples ```bash # All non-hidden directories recursively lscat -d * # All directories (including hidden) recursively lscat -d * -a # Current directory only (including hidden) lscat -d . -a # All .md files in current directory lscat -f *.md # All hidden files in current directory lscat -f .* # All .js files in src directory lscat -f src/*.js # All migration directories lscat -d server/database/migration*/ ``` ### Advanced Examples ```bash # Output to file with custom delimiter lscat -D output.txt -de "***" # Include hidden files, compress content, show line numbers lscat -a -c -l # Skip specific patterns lscat -s *.log -s node_modules -s .git # All non-hidden recursively (skip hidden) lscat -d * -a -s .* # Aggressive compression (all code in one line) lscat -C # Process project for AI analysis lscat -f *.md *.json -d src -s node_modules -s *.log -c -D ai_input.txt ``` ## üìã Options | Option | Short | Description | |--------|-------|-------------| | `--dir` | `-d` | Directories to process (supports patterns, recursive) | | `--file` | `-f` | Files to process (supports patterns, non-recursive) | | `--skip` | `-s` | Skip files/dirs matching pattern (supports wildcards) | | `--all` | `-a` | Include hidden files and directories | | `--destination` | `-D` | Output file(s) | | `--delimiter` | `-de` | Delimiter between file contents (default: "---") | | `--compress` | `-c` | Remove indentation and blank lines | | `--compress-hard` | `-C` | Aggressive compression (one-line per file) | | `--line-numbers` | `-l` | Show line numbers in file contents | | `--install` | `-i` | Install lscat system-wide | | `--help` | `-h` | Show help message | | `--version` | `-v` | Show version information | ## üéØ Behavior Summary | Command | Recursion | Hidden Files | Description | |---------|-----------|--------------|-------------| | `lscat` | ‚ùå Non-recursive | ‚úÖ Shows hidden | Tree of current directory | | `lscat -d .` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | Current directory only | | `lscat -d *` | ‚úÖ Recursive | ‚ùå Hides hidden (unless `-a`) | All directories recursively | | `lscat -f *` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | All files in current directory | | `lscat -f *.md` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | All .md files in current directory | ## üîß Pattern Syntax ### Directory Patterns (`-d` flag) ```bash # Wildcards (recursive) lscat -d * # All non-hidden directories lscat -d .* # All hidden directories lscat -d src/* # All items in src directory # Directory patterns lscat -d migration*/ # All migration directories lscat -d test* # All directories starting with 'test' # Multiple patterns lscat -d src lib tests ``` ### File Patterns (`-f` flag) ```bash # File patterns (non-recursive) lscat -f * # All non-hidden files in current directory lscat -f .* # All hidden files in current directory lscat -f *.md # All markdown files in current directory lscat -f src/*.js # All JS files in src directory (non-recursive) # Specific files lscat -f package.json README.md .gitignore ``` ### Skip Patterns (`-s` flag) ```bash # Skip by extension lscat -s *.log -s *.tmp # Skip directories lscat -s node_modules -s .git -s dist # Skip specific files lscat -s package-lock.json -s .env # Skip with wildcards lscat -s test_* -s *_backup.* # Skip paths lscat -s ./cache -s ./logs # Skip hidden items lscat -s .* ``` ## ‚ö° Skip Pattern Behavior The `-s` flag uses **intelligent pattern matching**: | Pattern Type | What it skips | Example | |--------------|---------------|---------| | **Exact name** | Items with exact name | `-s node_modules` skips `./node_modules` but not `src/node_modules.js` | | **Wildcard** | Pattern matches | `-s *.log` skips all `.log` files | | **Path pattern** | Items under path | `-s ./cache` skips `./cache` directory | | **Hidden items** | Hidden files/dirs | `-s .*` skips all hidden items | | **Directory only** | Directories only | `-s node_modules` only skips dirs named `node_modules` | **Note**: Skip patterns are applied after file/directory selection but before content processing. ## üìù Output Examples ### Tree Structure ``` üìÅ current-directory/ ‚îú‚îÄ‚îÄ üìÅ src/ ‚îÇ ‚îú‚îÄ‚îÄ üìÅ components/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Button.js ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Header.js ‚îÇ ‚îú‚îÄ‚îÄ App.js ‚îÇ ‚îî‚îÄ‚îÄ index.js ‚îú‚îÄ‚îÄ üìÅ public/ ‚îÇ ‚îú‚îÄ‚îÄ index.html ‚îÇ ‚îî‚îÄ‚îÄ favicon.ico ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ README.md ‚îî‚îÄ‚îÄ .gitignore ``` ### File Contents with Delimiter ``` File: src/App.js --- import React from 'react'; import Button from './components/Button'; function App() { return <Button>Click me</Button>; } export default App; ``` ## üé® Color Coding - **Blue**: Directories - **Green**: Text files (.txt, .md, no extension) - **Magenta**: Shell scripts (.sh, .bash) - **Yellow**: Python files (.py) - **Cyan**: JavaScript/TypeScript (.js, .ts) - **Default**: Other file types ## üí° Use Cases ### AI Analysis ```bash # Prepare codebase for AI analysis (skip unnecessary files) lscat -f *.md *.json -d src -s node_modules -s *.log -c -D codebase.txt ``` ### Documentation ```bash # Create project documentation lscat -f *.md -d docs -l -D documentation.txt ``` ### Code Review ```bash # Review source code only lscat -d src -s node_modules -s dist -l -c ``` ### Project Archive ```bash # Archive project structure and contents lscat -d * -f * -a -s node_modules -s .git -D project_archive.txt ``` ### Configuration Audit ```bash # Audit configuration files lscat -f .* *.json *.yml *.yaml -s .git -c -D config_audit.txt ``` ## ‚ö†Ô∏è Important Notes 1. **Flag Separation**: Files and directories must be specified with `-f` or `-d` flags 2. **Recursion**: `-d` is recursive with `*`, `-f` is non-recursive only 3. **Skip Patterns**: Applied to both files and directories with intelligent matching 4. **Compression**: - `-c`: Removes indentation and blank lines - `-C`: Aggressive compression (one line per file) 5. **Colors**: Automatically disabled when outputting to file 6. **Pattern Quotes**: Use quotes for patterns: `-f "*.md"` not `-f *.md` 7. **Install Option**: `-i` cannot be combined with other options ## üîÑ Version History - **1.4.0** - Added `-f` flag for file processing, improved skip pattern matching, removed positional arguments - **1.3.1** - Fixed default behavior consistency, enhanced pattern matching - **1.3.0** - Added comprehensive pattern support for all flags - **1.2.1** - Fixed regex errors, improved installation - **1.2.0** - Added compression and line numbering - **1.1.0** - Added skip patterns and hidden file handling - **1.0.0** - Initial release with basic listing and concatenation ## üìÑ License MIT License Copyright (c) 2023 [Lionel SISSO] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. See the [LICENSE](LICENSE) file for the full text. ## ü§ù Contributing Contributions are welcome! Please feel free to submit a Pull Request. 1. Fork the repository 2. Create your feature branch (`git checkout -b feature/AmazingFeature`) 3. Commit your changes (`git commit -m 'Add some AmazingFeature'`) 4. Push to the branch (`git push origin feature/AmazingFeature`) 5. Open a Pull Request ## üìß Support For issues, questions, or suggestions: - Open an issue on GitHub - Check the examples in this README - Use `lscat --help` for command reference --- Made with ‚ù§Ô∏è for developers and AI enthusiasts

File: ./test.txt
---
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê Directory Structure: ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê File Contents: ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê File: ./LICENSE --- MIT License Copyright (c) 2023 [LIONEL SISSO] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. File: ./lscat --- #!/bin/bash # ============================================================================= # lscat - List and concatenate directory/file contents with advanced options # Version: 1.5.0 (Added header-type option) # License: MIT - See LICENSE file for details # Repository: https://github.com/yourusername/lscat # ============================================================================= VERSION="1.5.0" SCRIPT_NAME=$(basename "$0") # Default values DELIMITER="---" INCLUDE_HIDDEN=false COMPRESS=false COMPRESS_HARD=false SHOW_LINE_NUMBERS=false OUTPUT_FILES=() SKIP_PATTERNS=() DIRECTORIES=() FILES=() CURRENT_DIR_ONLY=false NON_RECURSIVE=false POSITIONAL_DIRECTORIES=false # Flag to track if dirs were positional HEADER_TYPE="tree" # tree, ls, ls-R # ANSI color codes for better output (will be disabled when outputting to file) RED='\033[0;31m' GREEN='\033[0;32m' YELLOW='\033[1;33m' BLUE='\033[0;34m' MAGENTA='\033[0;35m' CYAN='\033[0;36m' NC='\033[0m' # No Color BOLD='\033[1m' # Flag to track if we're writing to file (so we can disable colors) WRITING_TO_FILE=false # ============================================================================= # Helper Functions # ============================================================================= print_help() { # Plain text help (no ANSI codes) echo "lscat - List and Concatenate Tool" echo "Version: $VERSION" echo "" echo "DESCRIPTION:" echo " Recursively lists directory structure and concatenates file contents with" echo " customizable delimiters. Useful for AI analysis, documentation, or bulk" echo " file processing." echo "" echo "USAGE:" echo " $SCRIPT_NAME [OPTIONS]" echo "" echo " Files and directories must be specified with -f or -d flags" echo "" echo "OPTIONS:" echo " -d, --dir DIR1 [DIR2...] Directories to process recursively" echo " -d * : All non-hidden directories recursively" echo " -d . : Current directory only (non-recursive)" echo " Supports patterns: *, .*, migration*/" echo " -f, --file FILE1 [FILE2...] Files to process (non-recursive only)" echo " -f * : All non-hidden files in current directory" echo " -f .* : All hidden files in current directory" echo " Supports patterns: *.md, *.js, etc." echo " Can specify full paths: -f client/src/app.js" echo " -s, --skip PATTERN Skip files/dirs matching pattern (can use multiple)" echo " Patterns match at any directory level" echo " Example: -s node_modules skips ALL node_modules dirs" echo " -a, --all Include hidden files and directories" echo " -D, --destination FILE Output file(s) (creates if doesn't exist)" echo " -de, --delimiter CHAR Delimiter between file contents (default: \"---\")" echo " -c, --compress Compress content (remove indentation and blank lines)" echo " -C, --compress-hard Aggressive compression (remove all formatting, one-line per file)" echo " -l, --line-numbers Show line numbers in file contents" echo " -H, --header-type TYPE Change header display style: tree (default), ls, ls-R" echo " tree: Full tree structure with branches" echo " ls: Simple ls-style list (compact)" echo " ls-R: Recursive ls-style list with subdir levels" echo " -i, --install Install lscat system-wide (standalone option)" echo " -h, --help Show this help message" echo " -v, --version Show version information" echo "" echo "BEHAVIOR:" echo " lscat # Non-recursive tree of current dir (shows hidden)" echo " lscat -d . # Same as above (explicit)" echo " lscat -d * # All directories recursively" echo " lscat -f * # All files in current directory (non-recursive)" echo "" echo "PATTERN EXAMPLES:" echo " lscat -d \"*\" # All non-hidden directories recursively" echo " lscat -d \"*\" -a # All directories (including hidden) recursively" echo " lscat -d . -a # Current directory only (including hidden)" echo " lscat -f '*.md' # All .md files in current directory" echo " lscat -f \".*\" # All hidden files in current directory" echo " lscat -f 'client/src/*.js' # All .js files in client/src" echo " lscat -d 'server/database/migration*/' # All migration directories" echo " lscat -s '*.log' # Skip all .log files" echo " lscat -s .git -s node_modules # Skip .git and node_modules directories" echo " lscat -s ./client/node_modules/ # Skip specific directory path" echo "" echo "HEADER TYPE EXAMPLES:" echo " lscat -d . -H tree # Default tree structure (verbose)" echo " lscat -d . -H ls # Compact ls-style listing" echo " lscat -d . -H ls-R # Recursive ls-style listing" echo " lscat -d * -c -H ls # Compact headers with compressed content" echo " lscat -d * -C -H ls # Hard compression with compact headers" echo "" echo "EXAMPLES:" echo " $SCRIPT_NAME # Non-recursive list of current directory" echo " $SCRIPT_NAME -d \"*\" -a -s .* # All non-hidden recursively (skip hidden)" echo " $SCRIPT_NAME -D output.txt -de \"***\" # Use custom delimiter, output to file" echo " $SCRIPT_NAME -a -c -l # Include hidden files, compress, line numbers" echo " $SCRIPT_NAME -f *.md -d client server # Process .md files and client/server directories" echo " $SCRIPT_NAME -f .gitignore readme.md -d src # Mix specific files and directories" echo "" echo "NOTES:" echo " - Use quotes around patterns to prevent shell expansion" echo " - Skip patterns prevent BOTH tree display AND file processing" echo " - Skip patterns match at any depth (e.g., -s node_modules skips all node_modules)" echo " - -d flag is for directories only (recursive with *)" echo " - -f flag is for files only (non-recursive, current directory only)" echo " - -H flag reduces header size when combining -d with -C or -c" echo " - Default (no flags): non-recursive tree of current dir, shows hidden" } print_version() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}lscat${NC} version ${GREEN}$VERSION${NC}" echo "Created for efficient file concatenation and AI processing" else echo "lscat version $VERSION" echo "Created for efficient file concatenation and AI processing" fi } print_error() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${RED}Error:${NC} $1" >&2 else echo "Error: $1" >&2 fi } print_warning() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}Warning:${NC} $1" >&2 else echo "Warning: $1" >&2 fi } print_info() { if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${CYAN}Info:${NC} $1" else echo "Info: $1" fi } # Installation function install_lscat() { echo "Installing lscat..." echo "=====================" # Get the script's own location if [[ -f "$0" ]]; then SCRIPT_PATH="$0" else # Fallback to the current script SCRIPT_PATH="./$(basename "$0")" fi if [[ ! -f "$SCRIPT_PATH" ]]; then print_error "Cannot find lscat script to install" exit 1 fi # Make sure the script is executable chmod +x "$SCRIPT_PATH" 2>/dev/null || true echo "" echo "Select installation method:" echo "1) Current user only (~/.local/bin) - Recommended" echo "2) System-wide (/usr/local/bin) - Requires sudo" echo "3) System-wide (/usr/bin) - Requires sudo" echo "4) Custom location with symlink" echo "5) Cancel installation" echo "" read -p "Enter choice [1-5]: " choice case $choice in 1) # User installation mkdir -p ~/.local/bin if cp "$SCRIPT_PATH" ~/.local/bin/lscat; then chmod +x ~/.local/bin/lscat echo "Installed to ~/.local/bin/lscat" # Check if PATH needs update if [[ ":$PATH:" != *":$HOME/.local/bin:"* ]]; then echo "Adding ~/.local/bin to PATH..." echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.bashrc echo 'export PATH="$HOME/.local/bin:$PATH"' >> ~/.zshrc 2>/dev/null || true source ~/.bashrc 2>/dev/null || true fi else print_error "Failed to copy to ~/.local/bin/" exit 1 fi ;; 2) # System installation to /usr/local/bin if sudo cp "$SCRIPT_PATH" /usr/local/bin/lscat; then sudo chmod +x /usr/local/bin/lscat echo "Installed to /usr/local/bin/lscat" else print_error "Failed to install to /usr/local/bin" exit 1 fi ;; 3) # System installation to /usr/bin if sudo cp "$SCRIPT_PATH" /usr/bin/lscat; then sudo chmod +x /usr/bin/lscat echo "Installed to /usr/bin/lscat" else print_error "Failed to install to /usr/bin" exit 1 fi ;; 4) # Custom symlink method read -p "Enter installation directory (e.g., /opt/lscat): " install_dir if [[ -z "$install_dir" ]]; then print_error "No directory specified" exit 1 fi mkdir -p "$install_dir" 2>/dev/null || sudo mkdir -p "$install_dir" if cp "$SCRIPT_PATH" "$install_dir/lscat"; then chmod +x "$install_dir/lscat" read -p "Create symlink in which directory? (e.g., /usr/local/bin): " symlink_dir if [[ -n "$symlink_dir" ]]; then sudo ln -sf "$install_dir/lscat" "$symlink_dir/lscat" 2>/dev/null || ln -sf "$install_dir/lscat" "$symlink_dir/lscat" echo "Installed to $install_dir/lscat with symlink in $symlink_dir" else echo "Installed to $install_dir/lscat (no symlink created)" fi else print_error "Failed to install to $install_dir" exit 1 fi ;; 5) echo "Installation cancelled." exit 0 ;; *) print_error "Invalid choice!" exit 1 ;; esac # Verify installation echo "" echo "Verifying installation..." if command -v lscat &> /dev/null; then echo -e "\033[32m‚úì lscat installed successfully!\033[0m" echo "Run 'lscat --help' to see usage" else echo -e "\033[31m‚úó Installation completed but lscat not found in PATH\033[0m" echo "You may need to log out and back in, or run: source ~/.bashrc" fi exit 0 } # Enhanced pattern expansion function (DIRECTORIES ONLY - recursive) expand_patterns() { local items=("$@") local expanded_items=() for item in "${items[@]}"; do # Special cases if [[ "$item" == "*" ]]; then # * means all non-hidden directories recursively if [[ "$INCLUDE_HIDDEN" == true ]]; then # Include hidden directories while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -print0 2>/dev/null) else # Exclude hidden directories while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]] && [[ ! "$found_item" =~ /\. ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -not -name '.*' -print0 2>/dev/null) fi elif [[ "$item" == "." ]] && [[ "$POSITIONAL_DIRECTORIES" == false ]]; then # . with -d flag means current directory only (non-recursive) expanded_items+=(".") elif [[ "$item" == ".*" ]]; then # .* means hidden directories recursively while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -mindepth 1 -type d -name '.*' -print0 2>/dev/null) elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then # Contains wildcard pattern - directories only # First, check if it's a literal directory that exists if [[ -d "$item" ]]; then # It exists as a literal directory expanded_items+=("$item") else # Try to expand with shell globbing (with nullglob to avoid literal pattern) shopt -s nullglob local found_items=() # Try with current directory if no directory specified if [[ "$item" != */* ]] && [[ "$item" != ./* ]]; then # Pattern without path - try in current directory for found_item in ./$item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done fi # Try the pattern as-is for found_item in $item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done shopt -u nullglob if [[ ${#found_items[@]} -eq 0 ]]; then # If no matches with shell globbing, try find for more complex patterns local pattern_name=$(basename "$item") local pattern_dir=$(dirname "$item") [[ "$pattern_dir" == "." ]] && pattern_dir="." # Handle directory patterns like migration*/ if [[ "$item" == */ ]]; then # Directory pattern while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null) else # General pattern (directories only) while IFS= read -r -d $'\0' found_item; do if [[ -d "$found_item" ]]; then found_items+=("$found_item") fi done < <(find "$pattern_dir" -type d -name "$pattern_name" -print0 2>/dev/null) fi fi # Add found items for found_item in "${found_items[@]}"; do expanded_items+=("$found_item") done fi else # No pattern, check if it's a directory if [[ -d "$item" ]]; then expanded_items+=("$item") elif [[ -e "$item" ]]; then print_warning "Skipping non-directory item in -d flag: $item" else print_error "Directory not found: $item" return 1 fi fi done # Remove duplicates and empty entries local unique_items=() for item in "${expanded_items[@]}"; do if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then unique_items+=("$item") fi done # Output each item on a new line for item in "${unique_items[@]}"; do echo "$item" done } # Enhanced file pattern expansion function (FILES ONLY - non-recursive) expand_file_patterns() { local items=("$@") local expanded_items=() for item in "${items[@]}"; do # Special cases if [[ "$item" == "*" ]]; then # * means all non-hidden files in current directory (non-recursive) if [[ "$INCLUDE_HIDDEN" == true ]]; then # Include hidden files while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -print0 2>/dev/null) else # Exclude hidden files while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -not -name '.*' -print0 2>/dev/null) fi elif [[ "$item" == ".*" ]]; then # .* means hidden files in current directory while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find . -maxdepth 1 -mindepth 1 -type f -name '.*' -print0 2>/dev/null) elif [[ "$item" == *"*"* ]] || [[ "$item" == *"?"* ]] || [[ "$item" == *"["* ]]; then # Contains wildcard pattern - files only, non-recursive local pattern_name=$(basename "$item") local pattern_dir=$(dirname "$item") [[ "$pattern_dir" == "." ]] && pattern_dir="." if [[ -d "$pattern_dir" ]] || [[ "$pattern_dir" == "" ]]; then # Use find with maxdepth 1 for non-recursive search if [[ "$INCLUDE_HIDDEN" == true ]]; then while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]]; then expanded_items+=("$found_item") fi done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -print0 2>/dev/null) else while IFS= read -r -d $'\0' found_item; do if [[ -f "$found_item" ]] && [[ ! "$(basename "$found_item")" == .* ]]; then expanded_items+=("$found_item") fi done < <(find "$pattern_dir" -maxdepth 1 -type f -name "$pattern_name" -not -name '.*' -print0 2>/dev/null) fi fi else # No pattern, check if it's a file if [[ -f "$item" ]]; then expanded_items+=("$item") elif [[ -e "$item" ]]; then print_warning "Skipping non-file item in -f flag: $item" else print_warning "File not found: $item" fi fi done # Remove duplicates and empty entries local unique_items=() for item in "${expanded_items[@]}"; do if [[ -n "$item" ]] && [[ ! " ${unique_items[@]} " =~ " $item " ]]; then unique_items+=("$item") fi done # Output each item on a new line for item in "${unique_items[@]}"; do echo "$item" done } # Enhanced should_skip with better directory handling should_skip() { local item="$1" local item_name=$(basename "$item") for pattern in "${SKIP_PATTERNS[@]}"; do # Remove trailing / if present pattern="${pattern%/}" # Skip empty patterns [[ -z "$pattern" ]] && continue # 1. Check exact match if [[ "$item" == "$pattern" ]] || [[ "$item_name" == "$pattern" ]]; then return 0 fi # 2. Check if pattern contains wildcards if [[ "$pattern" == *"*"* ]] || [[ "$pattern" == *"?"* ]] || [[ "$pattern" == *"["* ]]; then # Use case pattern matching case "$item" in $pattern) return 0 ;; esac case "$item_name" in $pattern) return 0 ;; esac fi # 3. Check for directory path matching (e.g., ./client/node_modules) # Remove leading ./ if present for better matching local clean_pattern="${pattern#./}" local clean_item="${item#./}" if [[ "$clean_item" == "$clean_pattern"* ]]; then # If pattern ends with a directory name and item is under that directory return 0 fi # 4. Check if item is inside a skipped directory # For each segment of the item path, check if it matches a skip pattern local temp_path="$clean_item" while [[ "$temp_path" != "." ]] && [[ "$temp_path" != "" ]]; do local current_dir="$(basename "$temp_path")" if [[ "$current_dir" == "$clean_pattern" ]] || [[ "$current_dir" == "$pattern" ]] || ([[ "$pattern" == *"*"* ]] && case "$current_dir" in $pattern) true;; *) false;; esac); then return 0 fi temp_path="$(dirname "$temp_path")" if [[ "$temp_path" == "/" ]] || [[ "$temp_path" == "." ]]; then break fi done done return 1 } # Normal compression - remove indentation and blank lines compress_content() { local content="$1" if [[ "$COMPRESS" == false ]] && [[ "$COMPRESS_HARD" == false ]]; then echo "$content" return fi # If hard compression is enabled, use that instead if [[ "$COMPRESS_HARD" == true ]]; then compress_hard_content "$content" return fi # Original compression: remove leading/trailing whitespace and empty lines echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//' -e '/^$/d' } # Hard compression - remove ALL formatting, make each file one continuous line compress_hard_content() { local content="$1" # First, remove all trailing/leading whitespace from each line content=$(echo "$content" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//') # Remove completely empty lines content=$(echo "$content" | sed -e '/^$/d') # Join lines with a single space, but be careful with certain patterns local result="" local in_multiline_comment=false local in_string=false local string_char="" # FIX: Define regex variables to avoid syntax errors with < > characters in conditionals local regex_open='[\({\[<]' local regex_close='[.,;:!?\)}\]>]' while IFS= read -r line; do # Skip empty lines [[ -z "$line" ]] && continue # Handle multiline comments if [[ "$in_multiline_comment" == true ]]; then if [[ "$line" == *"*/"* ]]; then in_multiline_comment=false fi result="${result}${line} " continue fi # Check if line starts a multiline comment if [[ "$line" == "/*"* ]] && [[ "$line" != *"*/"* ]]; then in_multiline_comment=true result="${result}${line} " continue fi if [[ -n "$result" ]]; then local last_char="${result: -1}" local first_char="${line:0:1}" # Use defined variables for pattern matching if [[ "$last_char" =~ $regex_open ]] || [[ "$first_char" =~ $regex_close ]]; then result="${result}${line} " else result="${result} ${line} " fi else result="${line} " fi done <<< "$content" # Clean up: remove trailing space and collapse multiple spaces result=$(echo "$result" | sed -e 's/[[:space:]]*$//' -e 's/[[:space:]]\+/ /g') if [[ ${#result} -gt 1000 ]] && [[ "$WRITING_TO_FILE" == false ]]; then print_warning "Hard compression created very long line (${#result} chars)" fi echo "$result" } # Enhanced get_tree_structure with proper skip handling get_tree_structure() { local dir="$1" local depth="${2:-0}" local prefix="${3:-}" local recursive="${4:-true}" local parent_is_hidden="${5:-false}" local force_show_hidden="${6:-false}" # Apply non-recursive flag if [[ "$NON_RECURSIVE" == true ]]; then recursive=false fi # Skip entire directory if it matches skip patterns if should_skip "$dir"; then if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}üìÅ $dir (skipped)${NC}" else echo "üìÅ $dir (skipped)" fi else echo "${prefix}üìÅ $(basename "$dir")/ (skipped)" fi return fi # Check if current directory is hidden (starts with .) local dir_name=$(basename "$dir") local is_current_hidden=false [[ "$dir_name" == .* ]] && is_current_hidden=true # Determine if we should show this directory if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then return fi # Print current directory if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}${BLUE}üìÅ $dir${NC}" else echo "üìÅ $dir" fi else echo "${prefix}üìÅ $dir_name/" fi # Find items in directory local find_opts="" if [[ "$recursive" == false ]]; then find_opts="-maxdepth 1" fi local find_cmd="find \"$dir\" $find_opts -mindepth 1" if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_current_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" local count=0 local total_items=0 # First, count total items while IFS= read -r item; do [[ -z "$item" ]] && continue total_items=$((total_items + 1)) done < <(eval "$find_cmd 2>/dev/null") # Process items while IFS= read -r item; do [[ -z "$item" ]] && continue local item_name=$(basename "$item") local is_item_hidden=false [[ "$item_name" == .* ]] && is_item_hidden=true # Skip if pattern matches if should_skip "$item"; then continue fi # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then continue fi count=$((count + 1)) # Determine if last item for pretty tree local next_prefix="$prefix" if [[ $count -eq $total_items ]]; then next_prefix="${prefix} " echo -n "${prefix}‚îî‚îÄ‚îÄ " else next_prefix="${prefix}‚îÇ " echo -n "${prefix}‚îú‚îÄ‚îÄ " fi if [[ -d "$item" ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BLUE}$item_name/${NC}" else echo "$item_name/" fi # Only recurse if recursive flag is true and not skipping if [[ "$recursive" == true ]] && ! should_skip "$item"; then get_tree_structure "$item" $((depth + 1)) "$next_prefix" "$recursive" "$is_current_hidden" "$force_show_hidden" fi else # Color code by file extension local ext="${item_name##*.}" if [[ "$WRITING_TO_FILE" == false ]]; then if [[ "$ext" == "$item_name" ]]; then echo -e "${GREEN}$item_name${NC}" elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then echo -e "${MAGENTA}$item_name${NC}" elif [[ "$ext" == "py" ]]; then echo -e "${YELLOW}$item_name${NC}" elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then echo -e "${CYAN}$item_name${NC}" elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then echo -e "${GREEN}$item_name${NC}" else echo "$item_name" fi else echo "$item_name" fi fi done < <(eval "$find_cmd 2>/dev/null") if [[ $count -eq 0 ]]; then echo "${prefix} (empty)" fi } # NEW: Get ls-style structure (compact, no tree branches) get_ls_structure() { local dir="$1" local depth="${2:-0}" local recursive="${3:-true}" local parent_is_hidden="${4:-false}" local force_show_hidden="${5:-false}" # Apply non-recursive flag if [[ "$NON_RECURSIVE" == true ]]; then recursive=false fi # Skip entire directory if it matches skip patterns if should_skip "$dir"; then if [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${YELLOW}üìÅ $dir (skipped)${NC}" else echo "üìÅ $dir (skipped)" fi fi return fi # Check if current directory is hidden (starts with .) local dir_name=$(basename "$dir") local is_current_hidden=false [[ "$dir_name" == .* ]] && is_current_hidden=true # Determine if we should show this directory if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_current_hidden" == true ]] && [[ "$parent_is_hidden" == false ]]; then return fi # Print current directory (with indentation for subdirectories in ls-R mode) local indent="" if [[ $depth -gt 0 ]] && [[ "$HEADER_TYPE" == "ls-R" ]]; then for ((i=0; i<depth; i++)); do indent="${indent} " done echo "${indent}$dir/" elif [[ $depth -eq 0 ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}${BLUE}üìÅ $dir${NC}" else echo "üìÅ $dir" fi fi # Find items in directory local find_opts="-maxdepth 1" if [[ "$recursive" == false ]]; then find_opts="-maxdepth 1" fi local find_cmd="find \"$dir\" $find_opts -mindepth 1" if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_current_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" # Process files and directories separately for better organization local files=() local subdirs=() while IFS= read -r item; do [[ -z "$item" ]] && continue local item_name=$(basename "$item") local is_item_hidden=false [[ "$item_name" == .* ]] && is_item_hidden=true # Skip if pattern matches if should_skip "$item"; then continue fi # Skip hidden items if INCLUDE_HIDDEN is false and not forcing show hidden if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_item_hidden" == true ]] && [[ "$is_current_hidden" == false ]]; then continue fi if [[ -d "$item" ]]; then subdirs+=("$item") else files+=("$item") fi done < <(eval "$find_cmd 2>/dev/null") # Print files first for item in "${files[@]}"; do local item_name=$(basename "$item") local ext="${item_name##*.}" # Add indentation for subdirectories in ls-R mode local item_indent="$indent" if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then item_indent="${item_indent} " fi if [[ "$WRITING_TO_FILE" == false ]]; then if [[ "$ext" == "$item_name" ]]; then echo -e "${item_indent}${GREEN}$item_name${NC}" elif [[ "$ext" == "sh" || "$ext" == "bash" ]]; then echo -e "${item_indent}${MAGENTA}$item_name${NC}" elif [[ "$ext" == "py" ]]; then echo -e "${item_indent}${YELLOW}$item_name${NC}" elif [[ "$ext" == "js" || "$ext" == "ts" ]]; then echo -e "${item_indent}${CYAN}$item_name${NC}" elif [[ "$ext" == "md" || "$ext" == "txt" ]]; then echo -e "${item_indent}${GREEN}$item_name${NC}" else echo "${item_indent}$item_name" fi else echo "${item_indent}$item_name" fi done # Print directories for item in "${subdirs[@]}"; do local item_name=$(basename "$item") local item_indent="$indent" if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then item_indent="${item_indent} " fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${item_indent}${BLUE}$item_name/${NC}" else echo "${item_indent}$item_name/" fi # Recurse into subdirectories if recursive flag is true and not skipping if [[ "$recursive" == true ]] && [[ "$HEADER_TYPE" == "ls-R" ]] && ! should_skip "$item"; then get_ls_structure "$item" $((depth + 1)) "$recursive" "$is_current_hidden" "$force_show_hidden" fi done # Print empty message if no items if [[ ${#files[@]} -eq 0 ]] && [[ ${#subdirs[@]} -eq 0 ]]; then if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -gt 0 ]]; then echo "${indent} (empty)" else echo " (empty)" fi fi # Add a blank line between directories in ls-R mode for readability if [[ "$HEADER_TYPE" == "ls-R" ]] && [[ $depth -eq 0 ]] && [[ ${#subdirs[@]} -gt 0 ]]; then echo "" fi } # Process file content with options process_file_content() { local file="$1" if [[ ! -f "$file" ]] || [[ ! -r "$file" ]]; then print_warning "Cannot read file: $file" return fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}File: ${CYAN}$file${NC}" else echo -e "\nFile: $file" fi echo "${DELIMITER}" local file_content file_content=$(cat "$file") if [[ "$SHOW_LINE_NUMBERS" == true ]]; then if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then local compressed_content compressed_content=$(compress_content "$file_content") local line_num=1 while IFS= read -r line; do printf "%6d %s\n" "$line_num" "$line" line_num=$((line_num + 1)) done <<< "$compressed_content" else cat -n "$file" fi elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then compress_content "$file_content" else cat "$file" fi } # Enhanced process_directory with HEADER_TYPE support process_directory() { local dir="$1" local dir_name=$(basename "$dir") local is_dir_hidden=false [[ "$dir_name" == .* ]] && is_dir_hidden=true local force_show_hidden="${2:-false}" # Skip entire directory if it matches skip patterns if should_skip "$dir"; then print_info "Skipping entire directory: $dir" return fi if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$is_dir_hidden" == true ]] && [[ "$dir" != "." ]] && [[ ! " ${DIRECTORIES[@]} " =~ " $dir " ]]; then return fi if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" echo -e "${BOLD}Directory Structure:${NC}" echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}\n" else echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" echo "Directory Structure:" echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n" fi # Determine recursion local recursive=true if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then recursive=false fi # Use appropriate header display based on HEADER_TYPE case "$HEADER_TYPE" in "tree") get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden" ;; "ls"|"ls-R") get_ls_structure "$dir" 0 "$recursive" false "$force_show_hidden" ;; *) get_tree_structure "$dir" 0 "" "$recursive" false "$force_show_hidden" ;; esac # Process file contents local show_file_contents=false if [[ "$INCLUDE_HIDDEN" == true ]] || [[ ${#SKIP_PATTERNS[@]} -gt 0 ]] || \ [[ ${#OUTPUT_FILES[@]} -gt 0 ]] || [[ "$COMPRESS" == true ]] || \ [[ "$SHOW_LINE_NUMBERS" == true ]]; then show_file_contents=true fi if [[ ${#VALID_DIRECTORIES[@]} -gt 1 ]] || [[ ${#VALID_FILES[@]} -gt 0 ]]; then show_file_contents=true fi if [[ "$show_file_contents" == true ]]; then if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "\n${BOLD}${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" echo -e "${BOLD}File Contents:${NC}" echo -e "${MAGENTA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê${NC}" else echo -e "\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" echo "File Contents:" echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" fi local find_cmd="find \"$dir\" -type f" # Apply recursion limit for non-recursive mode if [[ "$NON_RECURSIVE" == true ]] && [[ "$dir" == "." ]]; then find_cmd="$find_cmd -maxdepth 1" fi if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]]; then if [[ "$is_dir_hidden" == true ]]; then find_cmd="$find_cmd -not -name '.*'" else find_cmd="$find_cmd -not -name '.*' -not -path \"$dir/.*/*\"" fi fi find_cmd="$find_cmd | sort" local file_count=0 while IFS= read -r file; do [[ -z "$file" ]] && continue if should_skip "$file"; then continue; fi local file_name=$(basename "$file") if [[ "$force_show_hidden" == false ]] && [[ "$INCLUDE_HIDDEN" == false ]] && [[ "$file_name" == .* ]]; then continue; fi process_file_content "$file" file_count=$((file_count + 1)) done < <(eval "$find_cmd 2>/dev/null") if [[ $file_count -eq 0 ]]; then echo -e "\nNo files found to process in this directory." else echo -e "\nProcessed $file_count files from $dir" fi fi } # Process single file process_single_file() { local file="$1" if should_skip "$file"; then print_warning "Skipping file: $file" return fi print_info "Processing single file: $file" if [[ "$WRITING_TO_FILE" == false ]]; then echo -e "${BOLD}File: ${CYAN}$file${NC}" else echo "File: $file" fi echo "${DELIMITER}" local file_content=$(cat "$file") if [[ "$SHOW_LINE_NUMBERS" == true ]]; then if [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then local compressed_content=$(compress_content "$file_content") local line_num=1 while IFS= read -r line; do printf "%6d %s\n" "$line_num" "$line" line_num=$((line_num + 1)) done <<< "$compressed_content" else cat -n "$file" fi elif [[ "$COMPRESS" == true ]] || [[ "$COMPRESS_HARD" == true ]]; then compress_content "$file_content" else cat "$file" fi } # ============================================================================= # Main Argument Parsing # ============================================================================= # Handle install flag separately if [[ $# -eq 1 ]] && ([[ "$1" == "-i" ]] || [[ "$1" == "--install" ]]); then install_lscat fi # Parse arguments while [[ $# -gt 0 ]]; do case $1 in -h|--help) print_help; exit 0 ;; -v|--version) print_version; exit 0 ;; -d|--dir) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do DIRECTORIES+=("$1") shift done continue ;; -f|--file) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do FILES+=("$1") shift done continue ;; -s|--skip) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do SKIP_PATTERNS+=("$1") shift done continue ;; -a|--all) INCLUDE_HIDDEN=true ;; -D|--destination) shift # Collect all non-option arguments while [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; do OUTPUT_FILES+=("$1") shift done continue ;; -de|--delimiter) shift if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then DELIMITER="$1" shift else print_error "Delimiter requires a value" exit 1 fi ;; -c|--compress) COMPRESS=true ;; -C|--compress-hard) COMPRESS_HARD=true; COMPRESS=true ;; -l|--line-numbers) SHOW_LINE_NUMBERS=true ;; -H|--header-type) shift if [[ -n "$1" ]] && [[ ! "$1" =~ ^- ]]; then HEADER_TYPE="$1" shift # Validate header type case "$HEADER_TYPE" in "tree"|"ls"|"ls-R") # Valid, do nothing ;; *) print_error "Invalid header type: $HEADER_TYPE. Use tree, ls, or ls-R" exit 1 ;; esac else print_error "Header type requires a value: tree, ls, or ls-R" exit 1 fi ;; -i|--install) print_error "Install option (-i/--install) cannot be combined with other options"; exit 1 ;; -*) print_error "Unknown option: $1"; exit 1 ;; *) # Positional arguments are no longer supported print_error "Positional arguments are not supported. Use -d for directories or -f for files." print_error "Example: lscat -d . or lscat -f *.md" exit 1 ;; esac shift done # Handle default case (no arguments) if [[ ${#DIRECTORIES[@]} -eq 0 ]] && [[ ${#FILES[@]} -eq 0 ]]; then DIRECTORIES=(".") POSITIONAL_DIRECTORIES=true fi # Debug: show what we received # echo "DEBUG: Raw DIRECTORIES: ${DIRECTORIES[@]}" >&2 # echo "DEBUG: Raw FILES: ${FILES[@]}" >&2 # echo "DEBUG: Raw SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2 # Expand patterns in all arrays that support them if [[ ${#DIRECTORIES[@]} -gt 0 ]]; then # Create temporary array for expanded directories local temp_dirs=() for dir in "${DIRECTORIES[@]}"; do # Use mapfile to handle multi-line output from expand_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_dirs+=("$expanded_item") fi done < <(expand_patterns "$dir") done # Update DIRECTORIES with expanded items DIRECTORIES=("${temp_dirs[@]}") fi if [[ ${#FILES[@]} -gt 0 ]]; then # Create temporary array for expanded files local temp_files=() for file in "${FILES[@]}"; do # Use mapfile to handle multi-line output from expand_file_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_files+=("$expanded_item") fi done < <(expand_file_patterns "$file") done # Update FILES with expanded items FILES=("${temp_files[@]}") fi if [[ ${#SKIP_PATTERNS[@]} -gt 0 ]]; then # Create temporary array for expanded skip patterns local temp_skips=() for pattern in "${SKIP_PATTERNS[@]}"; do # Use mapfile to handle multi-line output from expand_patterns while IFS= read -r expanded_item; do if [[ -n "$expanded_item" ]]; then temp_skips+=("$expanded_item") fi done < <(expand_patterns "$pattern") done # Update SKIP_PATTERNS with expanded items SKIP_PATTERNS=("${temp_skips[@]}") fi # Debug: show what we expanded to # echo "DEBUG: Expanded DIRECTORIES: ${DIRECTORIES[@]}" >&2 # echo "DEBUG: Expanded FILES: ${FILES[@]}" >&2 # echo "DEBUG: Expanded SKIP_PATTERNS: ${SKIP_PATTERNS[@]}" >&2 # Set flags based on the directory specification if [[ " ${DIRECTORIES[@]} " =~ " . " ]] && [[ ${#DIRECTORIES[@]} -eq 1 ]]; then if [[ "$POSITIONAL_DIRECTORIES" == true ]]; then # lscat or lscat . (positional) - non-recursive, show hidden NON_RECURSIVE=true elif [[ "$INCLUDE_HIDDEN" == true ]]; then # lscat -d . -a - non-recursive, show hidden NON_RECURSIVE=true else # lscat -d . (without -a) - non-recursive, hide hidden NON_RECURSIVE=true fi fi VALID_DIRECTORIES=() VALID_FILES=() # Validate directories for dir in "${DIRECTORIES[@]}"; do if [[ -d "$dir" ]]; then VALID_DIRECTORIES+=("$dir") elif [[ -f "$dir" ]]; then print_warning "Directory expected but found file in -d flag: $dir (use -f for files)" else print_error "Directory not found: $dir" fi done # Validate files for file in "${FILES[@]}"; do if [[ -f "$file" ]]; then VALID_FILES+=("$file") elif [[ -d "$file" ]]; then print_warning "File expected but found directory in -f flag: $file (use -d for directories)" else print_warning "File not found: $file (skipping)" fi done # Process output if [[ ${#OUTPUT_FILES[@]} -gt 0 ]]; then WRITING_TO_FILE=true for output_file in "${OUTPUT_FILES[@]}"; do print_info "Output will be saved to: $output_file" > "$output_file" for dir in "${VALID_DIRECTORIES[@]}"; do if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then # Positional . shows hidden process_directory "$dir" true >> "$output_file" else # -d specified, use normal behavior process_directory "$dir" false >> "$output_file" fi done for file in "${VALID_FILES[@]}"; do process_single_file "$file" >> "$output_file" done done print_info "Output saved to specified file(s)" else for dir in "${VALID_DIRECTORIES[@]}"; do if [[ "$POSITIONAL_DIRECTORIES" == true ]] && [[ "$dir" == "." ]]; then # Positional . shows hidden process_directory "$dir" true else # -d specified, use normal behavior process_directory "$dir" false fi done for file in "${VALID_FILES[@]}"; do process_single_file "$file" done fi File: ./readme.md --- # lscat - Advanced List and Concatenate Tool `lscat` is a powerful command-line utility that combines directory listing with file concatenation capabilities, designed for AI analysis, documentation generation, and bulk file processing. ![Version](https://img.shields.io/badge/version-1.4.0-blue) ![Shell](https://img.shields.io/badge/shell-bash-green) ![License](https://img.shields.io/badge/license-MIT-green) ## ‚ú® Features - **Beautiful tree structure** display with color-coded file types - **Pattern matching** for directories (`-d`) and files (`-f`) with separate controls - **Flexible recursion control** - `-d` for recursive directory traversal, `-f` for non-recursive file selection - **Content concatenation** with customizable delimiters - **Compression options** for AI token optimization - **Hidden file control** with granular visibility options - **Output to file** with automatic color disabling - **Advanced skip patterns** for precise file/directory exclusion - **Line numbering** for code analysis - **Easy installation** with system-wide setup option ## üì¶ Installation ### Quick Install ```bash # Download and install git clone https://github.com/lionel-hue/LSCAT cd LSCAT chmod +x lscat ./lscat -i ``` Choose from these installation methods: 1. **User installation** (~/.local/bin) - Recommended 2. **System-wide** (/usr/local/bin) - Requires sudo 3. **System-wide** (/usr/bin) - Requires sudo 4. **Custom location** with symlink ## üöÄ Usage ### Basic Examples ```bash # Show beautiful tree of current directory (non-recursive, shows hidden) lscat # Process directories recursively lscat -d * # Process files in current directory only lscat -f * # Process specific directories lscat -d client server # Process specific files lscat -f .gitignore README.md package.json # Mix files and directories lscat -f *.md -d src tests ``` ### Pattern Examples ```bash # All non-hidden directories recursively lscat -d * # All directories (including hidden) recursively lscat -d * -a # Current directory only (including hidden) lscat -d . -a # All .md files in current directory lscat -f *.md # All hidden files in current directory lscat -f .* # All .js files in src directory lscat -f src/*.js # All migration directories lscat -d server/database/migration*/ ``` ### Advanced Examples ```bash # Output to file with custom delimiter lscat -D output.txt -de "***" # Include hidden files, compress content, show line numbers lscat -a -c -l # Skip specific patterns lscat -s *.log -s node_modules -s .git # All non-hidden recursively (skip hidden) lscat -d * -a -s .* # Aggressive compression (all code in one line) lscat -C # Process project for AI analysis lscat -f *.md *.json -d src -s node_modules -s *.log -c -D ai_input.txt ``` ## üìã Options | Option | Short | Description | |--------|-------|-------------| | `--dir` | `-d` | Directories to process (supports patterns, recursive) | | `--file` | `-f` | Files to process (supports patterns, non-recursive) | | `--skip` | `-s` | Skip files/dirs matching pattern (supports wildcards) | | `--all` | `-a` | Include hidden files and directories | | `--destination` | `-D` | Output file(s) | | `--delimiter` | `-de` | Delimiter between file contents (default: "---") | | `--compress` | `-c` | Remove indentation and blank lines | | `--compress-hard` | `-C` | Aggressive compression (one-line per file) | | `--line-numbers` | `-l` | Show line numbers in file contents | | `--install` | `-i` | Install lscat system-wide | | `--help` | `-h` | Show help message | | `--version` | `-v` | Show version information | ## üéØ Behavior Summary | Command | Recursion | Hidden Files | Description | |---------|-----------|--------------|-------------| | `lscat` | ‚ùå Non-recursive | ‚úÖ Shows hidden | Tree of current directory | | `lscat -d .` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | Current directory only | | `lscat -d *` | ‚úÖ Recursive | ‚ùå Hides hidden (unless `-a`) | All directories recursively | | `lscat -f *` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | All files in current directory | | `lscat -f *.md` | ‚ùå Non-recursive | ‚ùå Hides hidden (unless `-a`) | All .md files in current directory | ## üîß Pattern Syntax ### Directory Patterns (`-d` flag) ```bash # Wildcards (recursive) lscat -d * # All non-hidden directories lscat -d .* # All hidden directories lscat -d src/* # All items in src directory # Directory patterns lscat -d migration*/ # All migration directories lscat -d test* # All directories starting with 'test' # Multiple patterns lscat -d src lib tests ``` ### File Patterns (`-f` flag) ```bash # File patterns (non-recursive) lscat -f * # All non-hidden files in current directory lscat -f .* # All hidden files in current directory lscat -f *.md # All markdown files in current directory lscat -f src/*.js # All JS files in src directory (non-recursive) # Specific files lscat -f package.json README.md .gitignore ``` ### Skip Patterns (`-s` flag) ```bash # Skip by extension lscat -s *.log -s *.tmp # Skip directories lscat -s node_modules -s .git -s dist # Skip specific files lscat -s package-lock.json -s .env # Skip with wildcards lscat -s test_* -s *_backup.* # Skip paths lscat -s ./cache -s ./logs # Skip hidden items lscat -s .* ``` ## ‚ö° Skip Pattern Behavior The `-s` flag uses **intelligent pattern matching**: | Pattern Type | What it skips | Example | |--------------|---------------|---------| | **Exact name** | Items with exact name | `-s node_modules` skips `./node_modules` but not `src/node_modules.js` | | **Wildcard** | Pattern matches | `-s *.log` skips all `.log` files | | **Path pattern** | Items under path | `-s ./cache` skips `./cache` directory | | **Hidden items** | Hidden files/dirs | `-s .*` skips all hidden items | | **Directory only** | Directories only | `-s node_modules` only skips dirs named `node_modules` | **Note**: Skip patterns are applied after file/directory selection but before content processing. ## üìù Output Examples ### Tree Structure ``` üìÅ current-directory/ ‚îú‚îÄ‚îÄ üìÅ src/ ‚îÇ ‚îú‚îÄ‚îÄ üìÅ components/ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ Button.js ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ Header.js ‚îÇ ‚îú‚îÄ‚îÄ App.js ‚îÇ ‚îî‚îÄ‚îÄ index.js ‚îú‚îÄ‚îÄ üìÅ public/ ‚îÇ ‚îú‚îÄ‚îÄ index.html ‚îÇ ‚îî‚îÄ‚îÄ favicon.ico ‚îú‚îÄ‚îÄ package.json ‚îú‚îÄ‚îÄ README.md ‚îî‚îÄ‚îÄ .gitignore ``` ### File Contents with Delimiter ``` File: src/App.js --- import React from 'react'; import Button from './components/Button'; function App() { return <Button>Click me</Button>; } export default App; ``` ## üé® Color Coding - **Blue**: Directories - **Green**: Text files (.txt, .md, no extension) - **Magenta**: Shell scripts (.sh, .bash) - **Yellow**: Python files (.py) - **Cyan**: JavaScript/TypeScript (.js, .ts) - **Default**: Other file types ## üí° Use Cases ### AI Analysis ```bash # Prepare codebase for AI analysis (skip unnecessary files) lscat -f *.md *.json -d src -s node_modules -s *.log -c -D codebase.txt ``` ### Documentation ```bash # Create project documentation lscat -f *.md -d docs -l -D documentation.txt ``` ### Code Review ```bash # Review source code only lscat -d src -s node_modules -s dist -l -c ``` ### Project Archive ```bash # Archive project structure and contents lscat -d * -f * -a -s node_modules -s .git -D project_archive.txt ``` ### Configuration Audit ```bash # Audit configuration files lscat -f .* *.json *.yml *.yaml -s .git -c -D config_audit.txt ``` ## ‚ö†Ô∏è Important Notes 1. **Flag Separation**: Files and directories must be specified with `-f` or `-d` flags 2. **Recursion**: `-d` is recursive with `*`, `-f` is non-recursive only 3. **Skip Patterns**: Applied to both files and directories with intelligent matching 4. **Compression**: - `-c`: Removes indentation and blank lines - `-C`: Aggressive compression (one line per file) 5. **Colors**: Automatically disabled when outputting to file 6. **Pattern Quotes**: Use quotes for patterns: `-f "*.md"` not `-f *.md` 7. **Install Option**: `-i` cannot be combined with other options ## üîÑ Version History - **1.4.0** - Added `-f` flag for file processing, improved skip pattern matching, removed positional arguments - **1.3.1** - Fixed default behavior consistency, enhanced pattern matching - **1.3.0** - Added comprehensive pattern support for all flags - **1.2.1** - Fixed regex errors, improved installation - **1.2.0** - Added compression and line numbering - **1.1.0** - Added skip patterns and hidden file handling - **1.0.0** - Initial release with basic listing and concatenation ## üìÑ License MIT License Copyright (c) 2023 [Lionel SISSO] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. See the [LICENSE](LICENSE) file for the full text. ## ü§ù Contributing Contributions are welcome! Please feel free to submit a Pull Request. 1. Fork the repository 2. Create your feature branch (`git checkout -b feature/AmazingFeature`) 3. Commit your changes (`git commit -m 'Add some AmazingFeature'`) 4. Push to the branch (`git push origin feature/AmazingFeature`) 5. Open a Pull Request ## üìß Support For issues, questions, or suggestions: - Open an issue on GitHub - Check the examples in this README - Use `lscat --help` for command reference --- Made with ‚ù§Ô∏è for developers and AI enthusiasts File: ./test.txt ---

Processed 4 files from .
